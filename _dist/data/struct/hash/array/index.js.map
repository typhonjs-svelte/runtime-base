{"version":3,"file":"index.js","sources":["../../../../../node_modules/@typhonjs-svelte/trie-search/dist-trl/hash/index.js"],"sourcesContent":["import { isObject, klona, isIterable } from '#runtime/util/object';\n\n/**\n * Returns the value for a Key in the given item / object.\n *\n * @param {object}   item - The target item or partial item.\n *\n * @param {Key}      key - The Key to lookup in item.\n *\n * @returns {any} Value for key in item.\n */\nfunction getValueFromKey(item, key) {\n    if (!isObject(item)) {\n        throw new Error(`getValueFromKey error: 'item' must be an object.`);\n    }\n    if (typeof key === 'string') {\n        return item[key];\n    }\n    if (!Array.isArray(key)) {\n        return void 0;\n    }\n    if (key.length === 0) {\n        return void 0;\n    }\n    // else assume key is an array.\n    for (const k of key) {\n        if (typeof k !== 'string') {\n            return void 0;\n        }\n        if (item) {\n            item = item[k];\n        }\n        else {\n            break;\n        }\n    }\n    return item;\n}\n\n/**\n * Defines the operations for cloning items.\n */\nvar CloneOps;\n(function (CloneOps) {\n    /**\n     * Do not clone items.\n     */\n    CloneOps[CloneOps[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Copy items to new cloned HashArray.\n     */\n    CloneOps[CloneOps[\"SHALLOW\"] = 1] = \"SHALLOW\";\n    /**\n     * Clone all items.\n     */\n    CloneOps[CloneOps[\"DEEP\"] = 2] = \"DEEP\";\n})(CloneOps || (CloneOps = {}));\n/**\n * HashArray is a data structure that combines the best feature of a hash (O(1) retrieval) and an array\n * (length and ordering). Think of it as a super-lightweight, extensible, self-indexing set database in memory.\n *\n * @template T\n */\nclass HashArray {\n    /**\n     * An enum used in {@link HashArray.clone} determining how items are handled.\n     */\n    static CloneOps = CloneOps;\n    /**\n     * A single string or an array of strings / arrays representing what fields on added objects are to be used as keys\n     * for the trie search / HashArray.\n     */\n    #keyFields;\n    /**\n     * Stores all items added to the HashArray by order of addition.\n     */\n    #list;\n    /**\n     * Stores all items by associated key.\n     */\n    #map = new Map();\n    /**\n     * Stores HashArray options.\n     */\n    #options = {};\n    /**\n     * @param {string | KeyFields} [keyFields] - A single string or an array of strings / arrays representing what\n     * fields on added objects are to be used as keys for the trie search / HashArray.\n     *\n     * @param {HashArrayOptions<T>}   [options] - Options.\n     */\n    constructor(keyFields, options) {\n        if (keyFields !== void 0 && typeof keyFields !== 'string' && !Array.isArray(keyFields)) {\n            throw new TypeError(`HashArray.construct error: 'keyFields' is not a string or array.`);\n        }\n        if (options !== void 0 && !isObject(options)) {\n            throw new TypeError(`HashArray.construct error: 'options' is not an object.`);\n        }\n        this.#keyFields = Array.isArray(keyFields) ? keyFields : [keyFields];\n        if (typeof options?.ignoreDuplicates === 'boolean') {\n            this.#options.ignoreDuplicates = options.ignoreDuplicates;\n        }\n        this.#list = Array.isArray(options?.list) ? options.list : [];\n    }\n    /**\n     * @returns {KeyFields} A clone of the current key fields.\n     */\n    get keyFields() {\n        return klona(this.#keyFields);\n    }\n    /**\n     * @returns {number} The mapped size; number of keys in HashArray.\n     */\n    get size() {\n        return this.#map.size;\n    }\n    /**\n     * @returns {number} The flattened size; number of items in HashArray.\n     */\n    get sizeFlat() {\n        return this.#list.length;\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Adding Items\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Add items or list of items to the HashArray instance.\n     *\n     * @param {...(T | Iterable<T>)}  items - Items to add.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    add(...items) {\n        if (items.length === 0) {\n            return;\n        }\n        for (const itemOrList of items) {\n            if (isIterable(itemOrList)) {\n                for (const item of itemOrList) {\n                    this.#addOne(item);\n                }\n            }\n            else {\n                this.#addOne(itemOrList);\n            }\n        }\n        return this;\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Cloning\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Clones this HashArray. By default, returning an empty HashArray with cloned KeyFields. Set `items` in options\n     * to `CloneOps.SHALLOW` to copy the items. To fully clone all items set `CloneOps.DEEP`.\n     *\n     * @param {object}               [opts] - Optional parameters.\n     *\n     * @param {HashArray.CloneOps}   [opts.items=HashArray.CloneOps.NONE] - Clone operation for items. By default,\n     *        no items are included in the clone. Supply `SHALLOW` and items are copied. Supply `DEEP` and items are\n     *        cloned as well.\n     *\n     * @param {HashArrayOptions<T>}  [opts.options] - Optional change to options for the clone that is merged with\n     *        current HashArray options.\n     */\n    clone({ items = CloneOps.NONE, options } = {}) {\n        const result = new HashArray(klona(this.#keyFields), Object.assign({}, options, this.#options));\n        switch (items) {\n            case CloneOps.SHALLOW:\n                result.add(this.#list);\n                break;\n            case CloneOps.DEEP:\n                for (let i = 0; i < this.#list.length; i++) {\n                    result.add(klona(this.#list[i]));\n                }\n                break;\n        }\n        return result;\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Filtering\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Filters this HashArray returning a new HashArray with the items that pass the given filter test.\n     *\n     * @param {Key}   key - The Key to retrieve item(s) to iterate.\n     *\n     * @param {Key | ((T) => boolean)}  callbackOrIndex - A Key to lookup for filter inclusion or a callback function\n     *        returning the filter result for the item.\n     */\n    filter(key, callbackOrIndex) {\n        const callback = typeof callbackOrIndex === 'function' ? callbackOrIndex : (item) => {\n            const val = getValueFromKey(item, callbackOrIndex);\n            return val !== void 0 && val !== false;\n        };\n        return this.clone().add(this.getAll(key).filter(callback));\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Iterating Items\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Iterates over all items retrieved by the given key invoking the callback function for each item.\n     *\n     * @param {Key}   key - The Key to retrieve items to iterate.\n     *\n     * @param {(T) => void)}   callback - A callback invoked for each item.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    forEach(key, callback) {\n        const items = this.getAll(key);\n        items.forEach(callback);\n        return this;\n    }\n    /**\n     * Iterates over all items retrieved by the given key invoking the callback function for each item with the value\n     * found by the `index` Key and the item itself.\n     *\n     * @param {Key}   key - The Key to retrieve item(s) to iterate.\n     *\n     * @param {Key}   index - A specific Key in each item to lookup.\n     *\n     * @param {(value: any, item: T) => void)}   callback - A callback invoked for each item with value of `index`\n     *        and item.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    forEachDeep(key, index, callback) {\n        const items = this.getAll(key);\n        items.forEach((item) => callback(getValueFromKey(item, index), item));\n        return this;\n    }\n    /**\n     * @returns {IterableIterator<[string, T[]]>} An entries iterator w/ key and all associated values.\n     */\n    entries() {\n        return this.#map.entries();\n    }\n    /**\n     * @returns {IterableIterator<[string, T]>} Generator of flattened entries.\n     * @yields {[string, T]}\n     */\n    *entriesFlat() {\n        for (const key of this.#map.keys()) {\n            const items = this.#map.get(key);\n            for (const item of items) {\n                yield [key, item];\n            }\n        }\n    }\n    /**\n     * @returns {IterableIterator<string>} A keys iterator.\n     */\n    keys() {\n        return this.#map.keys();\n    }\n    /**\n     * @returns {IterableIterator<T[]>} A values iterator / all items values grouped by key.\n     */\n    values() {\n        return this.#map.values();\n    }\n    /**\n     * @returns {IterableIterator<T>} A flat values iterator by default in order added.\n     */\n    valuesFlat() {\n        return this.#list.values();\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Membership Testing\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Detects if the given item collides with an existing key / item pair.\n     *\n     * @param {Partial<T>}  item - A partial item to check for collision.\n     *\n     * @returns {boolean} Is there a collision?\n     */\n    collides(item) {\n        for (const keyField of this.#keyFields) {\n            if (this.has(getValueFromKey(item, keyField))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Verifies if this HashArray has this key.\n     *\n     * @param {string}   key - The key to check.\n     *\n     * @returns {boolean} Whether this HashArray already has the given key.\n     */\n    has(key) {\n        return this.#map.has(key);\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Removing Items\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Clears all items.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    clear() {\n        this.#map.clear();\n        this.#list.length = 0;\n        return this;\n    }\n    /**\n     * Removes all item(s) given.\n     *\n     * @param {...T}  items - Items to remove.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    remove(...items) {\n        for (const item of items) {\n            // Remove the item from the map.\n            this.#removeItemFromMap(item);\n            // Remove the item from the list.\n            const index = this.#list.indexOf(item);\n            if (index !== -1) {\n                this.#list.splice(index, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * Remove item(s) associated with the given keys from the HashArray.\n     *\n     * @param {string[]} keys - Keys associated with the item(s) to be removed.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    removeByKey(...keys) {\n        for (const key of keys) {\n            // Retrieve a shallow copy of the items associated with the key.\n            const items = this.#map.get(key)?.slice();\n            if (items) {\n                for (const item of items) {\n                    // Remove the item from the associated keys in the map.\n                    this.#removeItemFromMap(item);\n                    // Remove the item from the list.\n                    this.#list.splice(this.#list.indexOf(item), 1);\n                }\n            }\n            this.#map.delete(key);\n        }\n        return this;\n    }\n    /**\n     * When treating HashArray as a cache removing the first item removes the oldest item.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    removeFirst() {\n        if (this.#list.length) {\n            this.remove(this.#list[0]);\n        }\n        return this;\n    }\n    /**\n     * When treating HashArray as a cache removing the last item removes the newest item.\n     *\n     * @returns {HashArray<T>} This instance.\n     */\n    removeLast() {\n        if (this.#list.length) {\n            this.remove(this.#list[this.#list.length - 1]);\n        }\n        return this;\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Retrieving Items\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Gets item(s) by the given key.\n     *\n     * @param {string}   key - The key for an item to retrieve.\n     *\n     * @returns {T | T[]} All items stored by the given key.\n     */\n    get(key) {\n        const items = this.#map.get(key);\n        if (!items) {\n            return;\n        }\n        return items.length === 1 ? items[0] : items;\n    }\n    /**\n     * Gets all items stored by the given Key. You may pass `*` as a wildcard for all items.\n     *\n     * @param {Key}   keys - The Key for item(s) to retrieve.\n     *\n     * @returns {T[]} All item(s) for the given Key.\n     */\n    getAll(keys) {\n        const keysIsArray = Array.isArray(keys);\n        // Note: shallow copy of whole list.\n        if (keys === '*' || (keysIsArray && keys[0] === '*')) {\n            return [...this.#list];\n        }\n        const results = new Set();\n        if (keysIsArray) {\n            for (const key of keys) {\n                const items = this.get(key);\n                if (!items) {\n                    continue;\n                }\n                if (Array.isArray(items)) {\n                    for (const item of items) {\n                        results.add(item);\n                    }\n                }\n                else {\n                    results.add(items);\n                }\n            }\n        }\n        else {\n            const items = this.get(keys);\n            if (items) {\n                if (Array.isArray(items)) {\n                    for (const item of items) {\n                        results.add(item);\n                    }\n                }\n                else {\n                    results.add(items);\n                }\n            }\n        }\n        return [...results];\n    }\n    /**\n     * Gets item(s) by the given key always returning an array including an empty array when key is not in the HashArray.\n     *\n     * @param {string}   key - The key for item(s) to retrieve.\n     *\n     * @returns {T[]} All items for key or empty array.\n     */\n    getAsArray(key) {\n        return this.#map.get(key) ?? [];\n    }\n    /**\n     * Gets the item stored in the flat list of all items at the given index.\n     *\n     * @param {number}   index - The index to retrieve.\n     */\n    getAt(index) {\n        return this.#list[index];\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Set Operations\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Returns the intersection of this HashArray and a target HashArray.\n     *\n     * @param {HashArray<T>}   target - Another HashArray.\n     *\n     * @param {HashArray<T>}   [output] - Optional output HashArray.\n     *\n     * @returns {HashArray<T>} Returns a new HashArray that contains the intersection between this (A) and the HashArray\n     *          passed in (B). Returns A ^ B.\n     */\n    intersection(target, output = this.clone()) {\n        if (!(target instanceof HashArray)) {\n            throw new TypeError(`HashArray.intersection error: 'target' must be a HashArray.`);\n        }\n        for (const item of this.#list) {\n            for (const keyField of this.#keyFields) {\n                const key = getValueFromKey(item, keyField);\n                if (key && this.#map.get(key)?.includes?.(item) && target.#map.get(key)?.includes?.(item)) {\n                    output.add(item);\n                    break;\n                }\n            }\n        }\n        return output;\n    }\n    // Internal -------------------------------------------------------------------------------------------------------\n    /**\n     * Adds an item to this HashArray.\n     *\n     * @param {T}  item - Item to add.\n     */\n    #addOne(item) {\n        let added = true;\n        for (const keyField of this.#keyFields) {\n            const key = getValueFromKey(item, keyField);\n            if (key) {\n                const items = this.#map.get(key);\n                if (items) {\n                    if (this.#options.ignoreDuplicates) {\n                        return;\n                    }\n                    if (items.indexOf(item) !== -1) {\n                        // Already added for this KeyField, so continue;\n                        added = false;\n                        continue;\n                    }\n                    items.push(item);\n                }\n                else {\n                    this.#map.set(key, [item]);\n                }\n            }\n        }\n        // TODO: The indexOf check is one performance area that is difficult to improve.\n        if (added || this.#list.indexOf(item) === -1) {\n            this.#list.push(item);\n        }\n    }\n    /**\n     * Remove an item from the associated keys in the map.\n     *\n     * @param {T}  item - The item to be removed.\n     */\n    #removeItemFromMap(item) {\n        for (const keyField of this.#keyFields) {\n            const key = getValueFromKey(item, keyField);\n            if (key) {\n                const items = this.#map.get(key);\n                if (!items) {\n                    continue;\n                }\n                // Find the index of the item.\n                const index = items.indexOf(item);\n                // If the item is found, remove it from the array.\n                if (index !== -1) {\n                    items.splice(index, 1);\n                }\n                // If there are no more items for the key, delete the key from the map.\n                if (items.length === 0) {\n                    this.#map.delete(key);\n                }\n            }\n        }\n    }\n}\n\n/**\n * Provides extra examples of how various additional operations can be added on top of HashArray. These operations\n * are not included with HashArray to keep it lean and mean for {@link TrieSearch}. By all means though extend\n * HashArray and add the operations that you need.\n *\n * There are tests for all operations below in `./test/hash/HAExtra.test.ts`.\n */\nclass HashArrayUtil {\n    // ----------------------------------------------------------------------------------------------------------------\n    // Mathematical Operations\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Iterates deeply over items specified by `key` and `index` with an optional `weightKey` and calculates the\n     * average value.\n     *\n     * @template T\n     *\n     * @param {HashArray<T>} source - Source HashArray.\n     *\n     * @param {Key}   key - The Key to retrieve item(s) to iterate.\n     *\n     * @param {Key}   index - A specific Key in each item to lookup.\n     *\n     * @param {Key}   [weightKey] - A specific Key in each item to provide a weighting value.\n     *\n     * @returns {number} The average value for the given iteration.\n     */\n    static average(source, key, index, weightKey) {\n        let ret = 0;\n        let tot = 0;\n        let weightsTotal = 0;\n        if (weightKey !== void 0) {\n            source.forEachDeep(key, weightKey, (value) => weightsTotal += value);\n        }\n        source.forEachDeep(key, index, (value, item) => {\n            if (weightKey !== void 0) {\n                value *= (getValueFromKey(item, weightKey) / weightsTotal);\n            }\n            ret += value;\n            tot++;\n        });\n        return weightKey !== undefined ? ret : ret / tot;\n    }\n    /**\n     * Iterates deeply over items specified by `key` and `index` with an optional `weightKey` and calculates the sum.\n     *\n     * @template T\n     *\n     * @param {HashArray<T>}   source - Source HashArray.\n     *\n     * @param {Key}   key - The Key to retrieve item(s) to iterate.\n     *\n     * @param {Key}   index - A specific Key in each item to lookup.\n     *\n     * @param {Key}   [weightKey] - A specific Key in each item to provide a weighting value.\n     *\n     * @returns {number} The sum for the given iteration.\n     */\n    static sum(source, key, index, weightKey) {\n        let ret = 0;\n        source.forEachDeep(key, index, (value, item) => {\n            if (weightKey !== void 0) {\n                value *= getValueFromKey(item, weightKey);\n            }\n            ret += value;\n        });\n        return ret;\n    }\n    // ----------------------------------------------------------------------------------------------------------------\n    // Set Operations\n    // ----------------------------------------------------------------------------------------------------------------\n    /**\n     * Returns the difference of this HashArray and a target HashArray. If no output HashArray is provided the source\n     * is cloned.\n     *\n     * @template T\n     *\n     * @param {HashArray<T>}   source - Source HashArray.\n     *\n     * @param {HashArray<T>}   target - Target HashArray.\n     *\n     * @param {HashArray<T>}   output - Optional output HashArray.\n     *\n     * @returns {HashArray<T>} Returns a new HashArray that contains the difference between source (A) and target (B)\n     *          HashArrays. Returns A - B.\n     */\n    static difference(source, target, output) {\n        const result = output ? output : source.clone();\n        for (const item of source.valuesFlat()) {\n            if (!target.collides(item)) {\n                result.add(item);\n            }\n        }\n        return result;\n    }\n    /**\n     * @template T\n     *\n     * @param {HashArray<T>} source - Source HashArray.\n     *\n     * @param {number}   count - How many items to sample.\n     *\n     * @param {Key} [key] - The Key for item(s) to sample.\n     *\n     * @returns {T[]} Random subset of items.\n     * @see http://en.wikipedia.org/wiki/Image_(mathematics)\n     */\n    static sample(source, count, key) {\n        const image = key ? source.getAll(key) : [...source.valuesFlat()];\n        const result = [];\n        for (const randNum of this.#getUniqueRandomIntegers(count, 0, image.length - 1)) {\n            result.push(image[randNum]);\n        }\n        return result;\n    }\n    // Internal -------------------------------------------------------------------------------------------------------\n    /**\n     * @param {number}   count - Target count for length of returned results.\n     *\n     * @param {number}   min - Minimum index.\n     *\n     * @param {number}   max - Maximum index.\n     *\n     * @returns {Set<number>} An unique Set of random numbers between min & max; length is the minimum between count and\n     *          range of min / max.\n     */\n    static #getUniqueRandomIntegers(count, min, max) {\n        const set = new Set();\n        count = Math.min(Math.max(max - min, 1), count);\n        while (set.size < count) {\n            const r = Math.floor(min + (Math.random() * (max + 1)));\n            set.add(r);\n        }\n        return set;\n    }\n}\n\nexport { HashArray, HashArrayUtil, getValueFromKey };\n//# sourceMappingURL=index.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}