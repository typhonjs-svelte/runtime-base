{"version":3,"file":"index.js","sources":["../../../../node_modules/@typhonjs-plugin/manager/dist/eventbus/index.js"],"sourcesContent":["/**\n * Provides common utility functions for Eventbus / EventbusProxy.\n */\nclass EventbusUtils\n{\n   /**\n    * Used in instanceof checks to determine if callbacks are async.\n    *\n    * @type {Function}\n    */\n   static AsyncFunction = /* c8 ignore start */async function() {}.constructor;/* c8 ignore stop */\n\n   /**\n    * Used in instanceof checks to determine if callbacks are async.\n    *\n    * @type {Function}\n    */\n   static AsyncGeneratorFunction = /* c8 ignore start */async function *() {}.constructor;/* c8 ignore stop */\n\n   /**\n    * Regular expression used to split event strings.\n    *\n    * @type {RegExp}\n    */\n   static eventSplitter = /\\s+/;\n\n   /**\n    * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n    * callback` and event maps `{event: callback}`).\n    *\n    * @template T\n    *\n    * @param {Function}       iteratee - Event operation to invoke.\n    *\n    * @param {T}              events - EventbusEvents object\n    *\n    * @param {string | import('.').EventMap}  name - A single event name, compound event names, or a hash of event\n    *        names.\n    *\n    * @param {Function}       callback - Event callback function\n    *\n    * @param {object}         opts - Optional parameters\n    *\n    * @returns {T} EventbusEvents object or processed data.\n    */\n   static eventsAPI(iteratee, events, name, callback, opts)\n   {\n      let i = 0, names;\n      if (name && typeof name === 'object')\n      {\n         // Handle event maps.\n         if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }\n         for (names = EventbusUtils.objectKeys(name); i < names.length; i++)\n         {\n            events = EventbusUtils.eventsAPI(iteratee, events, names[i], name[names[i]], opts);\n         }\n      }\n      else if (name && typeof name === 'string' && EventbusUtils.eventSplitter.test(name))\n      {\n         // Handle space-separated event names by delegating them individually.\n         for (names = name.split(EventbusUtils.eventSplitter); i < names.length; i++)\n         {\n            events = iteratee(events, names[i], callback, opts);\n         }\n      }\n      else\n      {\n         // Finally, standard events.\n         events = iteratee(events, name, callback, opts);\n      }\n      return events;\n   }\n\n   /**\n    * Returns a string to output for error messages including any eventbus name.\n    *\n    * @param {import('.').Eventbus|import('.').EventbusProxy|import('.').EventbusSecure} eventbus - The eventbus to\n    *        format.\n    *\n    * @returns {string} A string representing the eventbus.\n    */\n   static getErrorName(eventbus)\n   {\n      const name = eventbus.name;\n      return name !== '' ? `[${name}] ` : '';\n   }\n\n   /**\n    * The reducing API that returns the options for an event. Any guarded event sets guard and the higher type is set.\n    *\n    * @param {object}   output - The output object.\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {object} The output object.\n    */\n   static getOptions(output, name, callback, opts)\n   {\n      const events = opts.events;\n\n      if (events)\n      {\n         const handlers = events[name];\n\n         if (Array.isArray(handlers))\n         {\n            for (const handler of handlers)\n            {\n               if (handler.options.guard)\n               {\n                  output.guard = true;\n               }\n\n               if (handler.options.type > output.type)\n               {\n                  output.type = handler.options.type;\n               }\n            }\n         }\n      }\n\n      return output;\n   }\n\n   /**\n    * Provides  protected Object.keys functionality.\n    *\n    * @param {object}   object - Object to retrieve keys.\n    *\n    * @returns {string[]} Keys of object if any.\n    */\n   static objectKeys(object)\n   {\n      return object === null || typeof object !== 'object' ? [] : Object.keys(object);\n   }\n\n   /**\n    * Reduces the event callbacks into a map of `{event: beforeWrapper}`. `after` unbinds the `beforeWrapper` after\n    * it has been called the number of times specified by options.count.\n    *\n    * @param {import('.').EventbusEvents}   map - EventbusEvents object\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Function to invoke after event has been triggered once; `off()`\n    *\n    * @returns {import('.').EventbusEvents} The EventbusEvents object.\n    */\n   static beforeMap(map, name, callback, opts)\n   {\n      const after = opts.after;\n      const count = opts.count + 1;\n\n      if (callback)\n      {\n         // @ts-ignore\n         const beforeWrapper = map[name] = EventbusUtils.#s_BEFORE(count, function()\n         {\n            return callback.apply(this, arguments);\n         }, () => { after(name, beforeWrapper); });\n\n         // @ts-ignore\n         beforeWrapper._callback = callback;\n      }\n      return map;\n   }\n\n   /**\n    * Creates a function that invokes `before`, with the `this` binding and arguments of the created function, while\n    * it's called less than `count` times. Subsequent calls to the created function return the result of the last `before`\n    * invocation.\n    *\n    * `after` is invoked after the count is reduced.\n    *\n    * @param {number}   count - The number of calls at which `before` is no longer invoked and then `after` is invoked.\n    *\n    * @param {Function} before - The function to restrict.\n    *\n    * @param {Function} after - The function to invoke after count number of calls.\n    *\n    * @returns {Function} Returns the new restricted function.\n    */\n   static #s_BEFORE(count, before, after)\n   {\n      let result;\n\n      return function(...args)\n      {\n         if (--count > 0) { result = before.apply(this, args); }\n\n         if (count <= 1)\n         {\n            if (after) { after.apply(this, args); }\n            after = void 0;\n            before = void 0;\n         }\n\n         return result;\n      };\n   }\n}\n\n/**\n * Provides the ability to bind and trigger custom named events. Bound callback functions may be triggered\n * asynchronously or synchronously returning results.\n */\nclass Eventbus\n{\n   /**\n    * Stores the name of this eventbus.\n    *\n    * @type {string}\n    */\n   #name = '';\n\n   /**\n    * Stores the events map for associated events and callback / context data.\n    *\n    * @type {import('.').EventbusEvents}\n    */\n   #events;\n\n   /**\n    * Provides a constructor which optionally takes the eventbus name.\n    *\n    * @param {string}   name - Optional eventbus name.\n    */\n   constructor(name = '')\n   {\n      if (typeof name !== 'string') { throw new TypeError(`'name' is not a string`); }\n\n      this.#name = name;\n\n      /**\n       * Stores the Listening instances for this context.\n       *\n       * @type {{ [key: string]: object }}\n       * @private\n       */\n      this._listeners = void 0;\n\n      /**\n       * A unique ID set when listened to.\n       *\n       * @type {string}\n       * @private\n       */\n      this._listenId = void 0;\n\n      /**\n       * Stores the Listening instances for other contexts.\n       *\n       * @type {{ [key: string]: object }}\n       * @private\n       */\n      this._listeningTo = void 0;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut} [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   before(count, name, callback, context = void 0, options = {})\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback,\n       { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Returns an iterable for all stored events yielding an array with event name, callback function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, Function, object, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, Function, object, import('.').EventOptionsOut]}\n    */\n   *entries(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns the current event count.\n    *\n    * @returns {number} Returns the current event count.\n    */\n   get eventCount()\n   {\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current callback count.\n    *\n    * @returns {number} The current callback count.\n    */\n   get callbackCount()\n   {\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns the options of an event name.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {import('.').EventOptionsOut} The event options.\n    */\n   getOptions(name)\n   {\n      const result = EventbusUtils.eventsAPI(EventbusUtils.getOptions, { guard: false, type: 0 }, name, void 0,\n       { events: this.#events });\n\n      let type = void 0;\n\n      switch (result.type)\n      {\n         case 1:\n            type = 'sync';\n            break;\n         case 2:\n            type = 'async';\n            break;\n      }\n\n      return { guard: result.guard, type };\n   }\n\n   /**\n    * Returns the trigger type of event name.\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {string|undefined} The trigger type.\n    */\n   getType(name)\n   {\n      const result = EventbusUtils.eventsAPI(Eventbus.#s_GET_TYPE, { type: 0 }, name, void 0, { events: this.#events });\n\n      switch (result.type)\n      {\n         case 1:\n            return 'sync';\n         case 2:\n            return 'async';\n         default:\n            return void 0;\n      }\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      data.names = [];\n      data.guarded = false;\n\n      const result = EventbusUtils.eventsAPI(Eventbus.#s_IS_GUARDED, data, name, void 0, { events: this.#events });\n\n      return result.guarded;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields {string}\n    */\n   *keys(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, import('.').EventOptionsOut]}\n    */\n   *keysWithOptions(regex = void 0)\n   {\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield [name, this.getOptions(name)];\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield [name, this.getOptions(name)];\n         }\n      }\n   }\n\n   /**\n    * Returns the current eventbus name.\n    *\n    * @returns {string} The current eventbus name.\n    */\n   get name()\n   {\n      return this.#name;\n   }\n\n   /**\n    * Tell an object to listen to a particular event on another object. The advantage of using this form, instead of\n    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can\n    * be removed all at once later on. The callback will always be called with object as context.\n    *\n    * @example\n    * ```js\n    * view.listenTo(model, 'change', view.render);\n    * ```\n    *\n    * @param {object}            obj - Event context\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenTo(obj, name, callback)\n   {\n      if (!obj) { return this; }\n\n      const data = {};\n      if (Eventbus.#s_TRY_CATCH_IS_GUARDED(obj, name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- listenTo() failed as event name(s) are guarded for target object: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      const id = obj._listenId || (obj._listenId = Eventbus.#s_UNIQUE_ID('l'));\n      const listeningTo = this._listeningTo || (this._listeningTo = {});\n      let listening = Eventbus.#listening = listeningTo[id];\n\n      // This object is not listening to any other events on `obj` yet.\n      // Set up the necessary references to track the listening callbacks.\n      if (!listening)\n      {\n         this._listenId || (this._listenId = Eventbus.#s_UNIQUE_ID('l'));\n         listening = Eventbus.#listening = listeningTo[id] = new Eventbus.#Listening(this, obj);\n      }\n\n      // Bind callbacks on obj.\n      const error = Eventbus.#s_TRY_CATCH_ON(obj, name, callback, this);\n      Eventbus.#listening = void 0;\n\n      if (error) { throw error; }\n\n      // If the target obj is not an Eventbus, track events manually.\n      if (listening.interop) { listening.on(name, callback); }\n\n      return this;\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire count times before being removed.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {object}            obj - Target event context.\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToBefore(count, obj, name, callback)\n   {\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback, {\n         count,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.\n    *\n    * @param {object}            obj - Target event context\n    *\n    * @param {string|import('.').EventMap}     name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   listenToOnce(obj, name, callback)\n   {\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback, {\n         count: 1,\n         after: this.stopListening.bind(this, obj)\n      });\n\n      return this.listenTo(obj, events);\n   }\n\n   /**\n    * Remove a previously-bound callback function from an object. If no context is specified, all the versions of\n    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event\n    * will be removed. If no event is specified, callbacks for all events will be removed.\n    *\n    * Note that calling model.off(), for example, will indeed remove all events on the model.\n    *\n    * @example\n    * ```js\n    * // Removes just the `onChange` callback.\n    * object.off('change', onChange);\n    *\n    * // Removes all 'change' callbacks.\n    * object.off('change');\n    *\n    * // Removes the `onChange` callback for all events.\n    * object.off(null, onChange);\n    *\n    * // Removes all callbacks for `context` for all events.\n    * object.off(null, null, context);\n    *\n    * // Removes all callbacks on `object`.\n    * object.off();\n    * ```\n    *\n    * @param {string|import('.').EventMap}   [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   off(name, callback = void 0, context = void 0)\n   {\n      if (!this.#events) { return this; }\n\n      this.#events = EventbusUtils.eventsAPI(Eventbus.#s_OFF_API, this.#events, name, callback,\n       { context, listeners: this._listeners });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: 'poll:start', or\n    * 'change:selection'.\n    *\n    * To supply a context value for this when the callback is invoked, pass the optional last argument:\n    * `model.on('change', this.render, this)` or `model.on({change: this.render}, this)`.\n    *\n    * @example\n    * ```js\n    * // The event string may also be a space-delimited list of several events...\n    * book.on('change:title change:author', ...);\n    * ```\n    *\n    * @example\n    * ```js\n    * Callbacks bound to the special 'all' event will be triggered when any event occurs, and are passed the name of\n    * the event as the first argument. For example, to proxy all events from one object to another:\n    * proxy.on('all', (eventName) => {\n    *    object.trigger(eventName);\n    * });\n    * ```\n    *\n    * @example\n    * ```js\n    * All event methods also support an event map syntax, as an alternative to positional arguments:\n    * book.on({\n    *    'change:author': authorPane.update,\n    *    'change:title change:subtitle': titleView.update,\n    *    'destroy': bookView.remove\n    * });\n    * ```\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   on(name, callback, context = void 0, options = {})\n   {\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\n      {\n         throw new TypeError(`'options' must be an object literal.`);\n      }\n\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      this.#events = EventbusUtils.eventsAPI(Eventbus.#s_ON_API, this.#events || {}, name, callback, {\n         context,\n         ctx: this,\n         options,\n         listening: Eventbus.#listening\n      });\n\n      if (Eventbus.#listening)\n      {\n         const listeners = this._listeners || (this._listeners = {});\n         listeners[Eventbus.#listening.id] = Eventbus.#listening;\n\n         // Allow the listening to use a counter, instead of tracking callbacks for library interop.\n         Eventbus.#listening.interop = false;\n      }\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context.\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut}         [options] - Event registration options.\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   once(name, callback, context = void 0, options = {})\n   {\n      const data = {};\n      if (this.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback,\n       { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove\n    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to\n    * on a specific object, or a specific event, or just a specific callback.\n    *\n    * @example\n    * ```js\n    * view.stopListening();\n    *\n    * view.stopListening(model);\n    * ```\n    *\n    * @param {object}   obj - Event context\n    *\n    * @param {string}   [name] - Event name(s)\n    *\n    * @param {Function} [callback] - Event callback function\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   stopListening(obj, name = void 0, callback = void 0)\n   {\n      const listeningTo = this._listeningTo;\n      if (!listeningTo) { return this; }\n\n      const ids = obj ? [obj._listenId] : EventbusUtils.objectKeys(listeningTo);\n\n      for (let i = 0; i < ids.length; i++)\n      {\n         const listening = listeningTo[ids[i]];\n\n         // If listening doesn't exist, this object is not currently listening to obj. Break out early.\n         if (!listening) { break; }\n\n         listening.obj.off(name, callback, this);\n\n         if (listening.interop) { listening.off(name, callback); }\n      }\n\n      return this;\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   trigger(name, ...args)\n   {\n      if (!this.#events) { return this; }\n\n      Eventbus.#s_RESULTS_TARGET_API(Eventbus.#s_TRIGGER_API, Eventbus.#s_TRIGGER_EVENTS, this.#events, name, void 0,\n       args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Promise<void|*|*[]>} A Promise with any results.\n    */\n   async triggerAsync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      const result = Eventbus.#s_RESULTS_TARGET_API(Eventbus.#s_TRIGGER_API, Eventbus.#s_TRIGGER_ASYNC_EVENTS,\n       this.#events, name, void 0, args);\n\n      // No event callbacks were triggered.\n      if (result === void 0) { return void 0; }\n\n      // A single Promise has been returned; just return it.\n      if (!Array.isArray(result)) { return result; }\n\n      // Multiple events & callbacks have been triggered so reduce the returned array of Promises and filter all\n      // values from each Promise result removing any undefined values.\n      return Promise.all(result).then((results) =>\n      {\n         let allResults = [];\n\n         for (const pResult of results)\n         {\n            if (Array.isArray(pResult))\n            {\n               allResults = allResults.concat(pResult);\n            }\n            else if (pResult !== void 0)\n            {\n               allResults.push(pResult);\n            }\n         }\n\n         return allResults.length > 1 ? allResults : allResults.length === 1 ? allResults[0] : void 0;\n      });\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Eventbus} This Eventbus instance.\n    */\n   triggerDefer(name, ...args)\n   {\n      setTimeout(() => { this.trigger(name, ...args); }, 0);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s).\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {void|*|*[]} The results of the event invocation.\n    */\n   triggerSync(name, ...args)\n   {\n      if (!this.#events) { return void 0; }\n\n      return Eventbus.#s_RESULTS_TARGET_API(Eventbus.#s_TRIGGER_API, Eventbus.#s_TRIGGER_SYNC_EVENTS, this.#events,\n       name, void 0, args);\n   }\n\n   // Internal static reducers and data ------------------------------------------------------------------------------\n\n   /**\n    * Generate a unique integer ID (unique within the entire client session).\n    *\n    * @type {number} - unique ID counter.\n    */\n   static #idCounter = 0;\n\n   /**\n    * Static listening object\n    *\n    * @type {object}\n    */\n   static #listening;\n\n   /**\n    * A listening class that tracks and cleans up memory bindings when all callbacks have been offed.\n    */\n   static #Listening = class\n   {\n      /**\n       * @type {import('.').EventbusEvents|{}}\n       */\n      #events;\n\n      /**\n       * @type {string}\n       */\n      #id;\n\n      /**\n       * @type {object}\n       */\n      #listener;\n\n      /**\n       * @type {object}\n       */\n      #obj;\n\n      /**\n       * @type {boolean}\n       */\n      #interop;\n\n      /**\n       * Current listening count.\n       *\n       * @type {number}\n       */\n      #count = 0;\n\n      constructor(listener, obj)\n      {\n         this.#id = listener._listenId;\n         this.#listener = listener;\n         this.#obj = obj;\n         this.#interop = true;\n      }\n\n      // Cleans up memory bindings between the listener and the target of the listener.\n      cleanup()\n      {\n         delete this.#listener._listeningTo[this.#obj._listenId];\n         if (!this.#interop) { delete this.#obj._listeners[this.#id]; }\n      }\n\n      get id() { return this.#id; }\n\n      get interop() { return this.#interop; }\n\n      get obj() { return this.#obj; }\n\n      incrementCount() { this.#count++; }\n\n      /**\n       * @see {@link Eventbus#on}\n       *\n       * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n       *\n       * @param {Function|object}   callback - Event callback function or context for event map.\n       *\n       * @param {object}            [context] - Event context\n       *\n       * @returns {object} This Listening instance.\n       */\n      on(name, callback, context = void 0)\n      {\n         this.#events = EventbusUtils.eventsAPI(Eventbus.#s_ON_API, this.#events || {}, name, callback,\n         {\n            context,\n            ctx: this,\n            options: {},\n            listening: this\n         });\n\n         return this;\n      }\n\n      /**\n       * Offs a callback (or several). Uses an optimized counter if the target of the listener uses Eventbus. Otherwise,\n       * falls back to manual tracking to support events library interop.\n       *\n       * @param {string|import('.').EventMap}   [name] - Event name(s) or event map.\n       *\n       * @param {Function|object}   [callback] - Event callback function or context for event map.\n       */\n      off(name, callback)\n      {\n         let cleanup;\n\n         if (this.#interop)\n         {\n            this.#events = EventbusUtils.eventsAPI(Eventbus.#s_OFF_API, this.#events, name, callback, {\n               context: void 0,\n               listeners: void 0\n            });\n            cleanup = !this.#events;\n         }\n         else\n         {\n            this.#count--;\n            cleanup = this.#count === 0;\n         }\n\n         if (cleanup) { this.cleanup(); }\n      }\n\n      /**\n       * Sets interop.\n       *\n       * @param {boolean} value Value to set.\n       */\n      set interop(value)\n      {\n         /* c8 ignore next 1 */\n         if (typeof value !== 'boolean') { throw new TypeError(`'value' is not a boolean`); }\n         this.#interop = value;\n      }\n   };\n\n   /**\n    * The reducing API that returns the trigger type for an event. The higher type is set.\n    *\n    * @param {object}   output - The output object.\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {object} The output object.\n    */\n   static #s_GET_TYPE(output, name, callback, opts)\n   {\n      const events = opts.events;\n\n      if (events)\n      {\n         const handlers = events[name];\n\n         if (Array.isArray(handlers))\n         {\n            for (const handler of handlers)\n            {\n               if (handler.options.type > output.type)\n               {\n                  output.type = handler.options.type;\n               }\n            }\n         }\n      }\n\n      return output;\n   }\n\n   /**\n    * The reducing API that tests if an event name is guarded. Any event data of a give event name can have the guarded\n    * state set. If so the event name will be added to the output names array and `output.guarded` set to true.\n    *\n    * @param {object}   output - The output object.\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {object} The output object.\n    */\n   static #s_IS_GUARDED(output, name, callback, opts)\n   {\n      const events = opts.events;\n\n      if (events)\n      {\n         const handlers = events[name];\n\n         if (Array.isArray(handlers))\n         {\n            for (const handler of handlers)\n            {\n               if (handler.options.guard)\n               {\n                  output.names.push(name);\n                  output.guarded = true;\n                  return output;\n               }\n            }\n         }\n      }\n\n      return output;\n   }\n\n   /**\n    * The reducing API that removes a callback from the `events` object.\n    *\n    * @param {import('.').EventbusEvents}   events - EventbusEvents object\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {void | import('.').EventbusEvents} EventbusEvents object\n    */\n   static #s_OFF_API(events, name, callback, opts)\n   {\n      /* c8 ignore next 1 */\n      if (!events) { return; }\n\n      const context = opts.context, listeners = opts.listeners;\n      let i = 0, names;\n\n      // Delete all event listeners and `drop` events.\n      if (!name && !context && !callback)\n      {\n         for (names = EventbusUtils.objectKeys(listeners); i < names.length; i++)\n         {\n            listeners[names[i]].cleanup();\n         }\n         return;\n      }\n\n      names = name ? [name] : EventbusUtils.objectKeys(events);\n\n      for (; i < names.length; i++)\n      {\n         name = names[i];\n         const handlers = events[name];\n\n         // Bail out if there are no events stored.\n         if (!handlers) { break; }\n\n         // Find any remaining events.\n         const remaining = [];\n         for (let j = 0; j < handlers.length; j++)\n         {\n            const handler = handlers[j];\n            // @ts-ignore\n            if (callback && callback !== handler.callback && callback !== handler.callback._callback ||\n             context && context !== handler.context)\n            {\n               remaining.push(handler);\n            }\n            else\n            {\n               const listening = handler.listening;\n               if (listening) { listening.off(name, callback); }\n            }\n         }\n\n         // Replace events if there are any remaining.  Otherwise, clean up.\n         if (remaining.length)\n         {\n            events[name] = remaining;\n         }\n         else\n         {\n            delete events[name];\n         }\n      }\n\n      return events;\n   }\n\n   /**\n    * The reducing API that adds a callback to the `events` object.\n    *\n    * @param {import('.').EventbusEvents}   events - EventbusEvents object\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {import('.').EventbusEvents} EventbusEvents object.\n    */\n   static #s_ON_API(events, name, callback, opts)\n   {\n      if (callback)\n      {\n         const handlers = events[name] || (events[name] = []);\n         const context = opts.context, ctx = opts.ctx, listening = opts.listening;\n\n         // Make a copy of options.\n         const options = JSON.parse(JSON.stringify(opts.options));\n\n         // Ensure that guard is set.\n         options.guard = typeof options.guard === 'boolean' ? options.guard : false;\n\n         // Determine automatically if the callback is `async` via being defined with the `async` modifier.\n         if (callback instanceof EventbusUtils.AsyncFunction ||\n          callback instanceof EventbusUtils.AsyncGeneratorFunction)\n         {\n            options.type = 2;\n         }\n         else\n         {\n            // Ensure that type is set.\n            switch (options.type)\n            {\n               case 'sync':\n                  options.type = 1;\n                  break;\n               case 'async':\n                  options.type = 2;\n                  break;\n               default:\n                  options.type = 0;\n                  break;\n            }\n         }\n\n         if (listening) { listening.incrementCount(); }\n\n         handlers.push({ callback, context, ctx: context || ctx, options, listening });\n      }\n      return events;\n   }\n\n   /**\n    * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `\"change blur\",\n    * callback` and event maps `{event: callback}`).\n    *\n    * @param {Function} iteratee - Trigger API\n    *\n    * @param {Function} iterateeTarget - Internal function which is dispatched to.\n    *\n    * @param {import('.').EventbusEvents | {}}   events - Array of stored event callback data.\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {*} The results of the callback if any.\n    */\n   static #s_RESULTS_TARGET_API(iteratee, iterateeTarget, events, name, callback, opts)\n   {\n      let results = void 0;\n      let i = 0, names;\n\n      // Handle the case of multiple events being triggered. The potential results of each event & callbacks must be\n      // processed into a single array of results.\n      if (name && EventbusUtils.eventSplitter.test(name))\n      {\n         // Handle space-separated event names by delegating them individually.\n         for (names = name.split(EventbusUtils.eventSplitter); i < names.length; i++)\n         {\n            const result = iteratee(iterateeTarget, events, names[i], callback, opts);\n\n            // Determine type of `results`; 0: undefined, 1: single value, 2: an array of values.\n            const resultsType = Array.isArray(results) ? 2 : results !== void 0 ? 1 : 0;\n\n            // Handle an array result depending on existing results value.\n            if (Array.isArray(result))\n            {\n               switch (resultsType)\n               {\n                  case 0:\n                     // Simply set results.\n                     results = result;\n                     break;\n                  case 1:\n                     // Create a new array from existing results then concat the new result array.\n                     results = [results].concat(result);\n                     break;\n                  case 2:\n                     // `results` is already an array so concat the new result array.\n                     results = results.concat(result);\n                     break;\n               }\n            }\n            else if (result !== void 0)\n            {\n               switch (resultsType)\n               {\n                  case 0:\n                     // Simply set results.\n                     results = result;\n                     break;\n                  case 1: {\n                     // Create a new array from existing results then push the new result value.\n                     const newArray = [results];\n                     newArray.push(result);\n                     results = newArray;\n                     break;\n                  }\n                  case 2:\n                     // `results` is already an array so push the new result array.\n                     results.push(result);\n                     break;\n               }\n            }\n         }\n      }\n      else\n      {\n         // Just single event.\n         results = iteratee(iterateeTarget, events, name, callback, opts);\n      }\n\n      return results;\n   }\n\n   /**\n    * Handles triggering the appropriate event callbacks.\n    *\n    * @param {Function} iterateeTarget - Internal function which is dispatched to.\n    *\n    * @param {import('.').EventbusEvents}   objEvents - Array of stored event callback data.\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - callback\n    *\n    * @param {*[]}      args - Arguments supplied to a trigger method.\n    *\n    * @returns {*} The results from the triggered event.\n    */\n   static #s_TRIGGER_API(iterateeTarget, objEvents, name, callback, args)\n   {\n      let result;\n\n      if (objEvents)\n      {\n         const events = objEvents[name];\n         let allEvents = objEvents.all;\n         if (events && allEvents) { allEvents = allEvents.slice(); }\n         if (events) { result = iterateeTarget(events, args); }\n         if (allEvents) { result = iterateeTarget(allEvents, [name].concat(args)); }\n      }\n\n      return result;\n   }\n\n   /**\n    * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n    * cases speedy.\n    *\n    * @param {import('.').EventData[]} events - Array of stored event callback data.\n    *\n    * @param {*[]}         args - Event argument array\n    */\n   static #s_TRIGGER_EVENTS(events, args)\n   {\n      let ev, i = -1;\n      const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }\n            return;\n         case 1:\n            while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }\n            return;\n         case 2:\n            while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }\n            return;\n         case 3:\n            while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }\n            return;\n         default:\n            while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }\n            return;\n      }\n   }\n\n   /**\n    * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n    * cases speedy. This dispatch method uses ES6 Promises and adds any returned results to an array which is added to\n    * a `Promise.all` construction which passes back a Promise which waits until all Promises complete. Any target\n    * invoked may return a Promise or any result. This is very useful to use for any asynchronous operations.\n    *\n    * @param {import('.').EventData[]} events - Array of stored event callback data.\n    *\n    * @param {*[]}         args - Arguments supplied to `triggerAsync`.\n    *\n    * @returns {Promise<void|*|*[]>} A Promise of the results from the triggered event.\n    */\n   static async #s_TRIGGER_ASYNC_EVENTS(events, args)\n   {\n      let ev, i = -1;\n      const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n      const results = [];\n\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 1:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 2:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         case 3:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n\n         default:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n               // If we received a valid result add it to the promises array.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n      }\n\n      // If there are multiple results then use Promise.all otherwise Promise.resolve. Filter out any undefined results.\n      return results.length > 1 ? Promise.all(results).then((values) =>\n      {\n         const filtered = values.filter((entry) => entry !== void 0);\n         switch (filtered.length)\n         {\n            case 0: return void 0;\n            case 1: return filtered[0];\n            default: return filtered;\n         }\n      }) : results.length === 1 ? results[0] : void 0;\n   }\n\n   /**\n    * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual\n    * cases speedy. This dispatch method synchronously passes back a single value or an array with all results returned\n    * by any invoked targets.\n    *\n    * @param {import('.').EventData[]} events - Array of stored event callback data.\n    *\n    * @param {*[]}         args - Arguments supplied to `triggerSync`.\n    *\n    * @returns {void|*|*[]} The results from the triggered event.\n    */\n   static #s_TRIGGER_SYNC_EVENTS(events, args)\n   {\n      let ev, i = -1;\n      const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;\n\n      const results = [];\n\n      switch (args.length)\n      {\n         case 0:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx);\n\n               // If we received a valid result return immediately.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n         case 1:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1);\n\n               // If we received a valid result return immediately.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n         case 2:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2);\n\n               // If we received a valid result return immediately.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n         case 3:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);\n\n               // If we received a valid result return immediately.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n         default:\n            while (++i < l)\n            {\n               const result = (ev = events[i]).callback.apply(ev.ctx, args);\n\n               // If we received a valid result return immediately.\n               if (result !== void 0) { results.push(result); }\n            }\n            break;\n      }\n\n      // Return the results array if there are more than one or just a single result.\n      return results.length > 1 ? results : results.length === 1 ? results[0] : void 0;\n   }\n\n   /**\n    * A try-catch guarded function. Used when attempting to invoke `isGuarded` from another eventbus / context via\n    * `listenTo`.\n    *\n    * @param {object}         obj - Event target / context\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {object}         data - Output data.\n    *\n    * @returns {boolean} Any error if thrown.\n    */\n   static #s_TRY_CATCH_IS_GUARDED(obj, name, data = {})\n   {\n      let guarded = false;\n\n      try\n      {\n         const result = obj.isGuarded(name, data);\n         if (typeof result === 'boolean') { guarded = result; }\n      }\n      catch (err)\n      {\n         guarded = false;\n         data.names = [];\n         data.guarded = false;\n      }\n\n      return guarded;\n   }\n\n   /**\n    * A try-catch guarded #on function, to prevent poisoning the static `Eventbus.#listening` variable. Used when\n    * attempting to invoke `on` from another eventbus / context via `listenTo`.\n    *\n    * @param {object}            obj - Event target / context\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @returns {Error} Any error if thrown.\n    */\n   static #s_TRY_CATCH_ON(obj, name, callback, context)\n   {\n      let error;\n\n      try\n      {\n         obj.on(name, callback, context);\n      }\n      catch (err)\n      {\n         error = err;\n      }\n\n      return error;\n   }\n\n   /**\n    * Creates a new unique ID with a given prefix\n    *\n    * @param {string}   prefix - An optional prefix to add to unique ID.\n    *\n    * @returns {string} A new unique ID with a given prefix.\n    */\n   static #s_UNIQUE_ID(prefix = '')\n   {\n      const id = `${++Eventbus.#idCounter}`;\n      return prefix ? `${prefix}${id}` /* c8 ignore next */ : id;\n   }\n}\n\n/**\n * EventbusProxy provides a protected proxy of another Eventbus instance.\n *\n * The main use case of EventbusProxy is to allow indirect access to an eventbus. This is handy when it comes to\n * managing the event lifecycle for a plugin system. When a plugin is added it could receive a callback, perhaps named\n * `onPluginLoaded`, which contains an EventbusProxy instance rather than the direct eventbus. This EventbusProxy\n * instance is associated in the management system controlling plugin lifecycle. When a plugin is removed / unloaded the\n * management system can automatically unregister all events for the plugin without requiring the plugin author doing it\n * correctly if they had full control. IE This allows to plugin system to guarantee no dangling listeners.\n *\n * EventbusProxy provides the on / off, before, once, and trigger methods with the same signatures as found in\n * Eventbus. However, the proxy tracks all added event bindings which is used to proxy between the target\n * eventbus which is passed in from the constructor. All registration methods (on / off / once) proxy. In addition,\n * there is a `destroy` method which will unregister all of proxied events and remove references to the managed\n * eventbus. Any further usage of a destroyed EventbusProxy instance results in a ReferenceError thrown.\n *\n * Finally, the EventbusProxy only allows events registered through it to be turned off providing a buffer between\n * any consumers such that they can not turn off other registrations made on the eventbus or other proxy instances.\n */\nclass EventbusProxy\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {import('.').Eventbus}\n    */\n   #eventbus;\n\n   /**\n    * Stores all proxied event bindings.\n    *\n    * @type {import('.').EventbusEvents}\n    */\n   #events;\n\n   /**\n    * Creates the event proxy with an existing instance of Eventbus.\n    *\n    * @param {import('.').Eventbus}   eventbus - The target eventbus instance.\n    */\n   constructor(eventbus)\n   {\n      this.#eventbus = eventbus;\n\n      Object.seal(this);\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire several times up to the count specified before being\n    * removed. When multiple events are passed in using the space separated syntax, the event\n    * will fire count times for every event you passed in, not once for a combination of all events.\n    *\n    * @param {number}            count - Number of times the function will fire before being removed.\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut}   [options] - Event registration options.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   before(count, name, callback, context = void 0, options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (!Number.isInteger(count)) { throw new TypeError(`'count' is not an integer`); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- before() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback,\n       { count, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Creates an EventbusProxy wrapping the backing Eventbus instance. An EventbusProxy proxies events allowing all\n    * listeners added to be easily removed from the wrapped Eventbus.\n    *\n    * @returns {EventbusProxy} A new EventbusProxy for this eventbus.\n    */\n   createProxy()\n   {\n      return new EventbusProxy(this.#eventbus);\n   }\n\n   /**\n    * Unregisters all proxied events from the target eventbus and removes any local references. All subsequent calls\n    * after `destroy` has been called result in a ReferenceError thrown.\n    */\n   destroy()\n   {\n      if (this.#eventbus !== null)\n      {\n         this.off();\n      }\n\n      this.#events = void 0;\n\n      this.#eventbus = null;\n   }\n\n   /**\n    * Returns an iterable for all events from the proxied eventbus yielding an array with event name, callback function,\n    * and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, Function, object, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, Function, object, import('.').EventOptionsOut]}\n    */\n   *entries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.entries(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns the current proxied eventbus event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get eventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.eventCount;\n   }\n\n   /**\n    * Returns the current proxied eventbus callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get callbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.callbackCount;\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of proxied eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields {string}\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, import('.').EventOptionsOut]}\n    */\n   *keysWithOptions(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keysWithOptions(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this EventbusProxy has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the target eventbus name.\n    *\n    * @returns {string} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return `proxy-${this.#eventbus.name}`;\n   }\n\n   /**\n    * Returns the current proxied event count.\n    *\n    * @returns {number} Returns the current proxied event count.\n    */\n   get proxyEventCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      return Object.keys(this.#events).length;\n   }\n\n   /**\n    * Returns the current proxied callback count.\n    *\n    * @returns {number} Returns the current proxied callback count.\n    */\n   get proxyCallbackCount()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (!this.#events) { return 0; }\n\n      let count = 0;\n\n      for (const name in this.#events) { count += this.#events[name].length; }\n\n      return count;\n   }\n\n   /**\n    * Returns the options of an event name.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {import('.').EventOptionsOut} The event options.\n    */\n   getOptions(name)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.getOptions(name);\n   }\n\n   /**\n    * Returns the trigger type of event name.\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {string|undefined} The trigger type.\n    */\n   getType(name)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.getType(name);\n   }\n\n   /**\n    * Returns whether an event name is guarded.\n    *\n    * @param {string|import('.').EventMap}  name - Event name(s) or event map to verify.\n    *\n    * @param {object}         [data] - Stores the output of which names are guarded.\n    *\n    * @returns {boolean} Whether the given event name is guarded.\n    */\n   isGuarded(name, data = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.isGuarded(name, data);\n   }\n\n   /**\n    * Remove a previously-bound proxied event binding.\n    *\n    * Please see {@link Eventbus#off}.\n    *\n    * @param {string|import('.').EventMap}  [name] - Event name(s) or event map.\n    *\n    * @param {Function}       [callback] - Event callback function\n    *\n    * @param {object}         [context] - Event context\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   off(name = void 0, callback = void 0, context = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#events = EventbusUtils.eventsAPI(EventbusProxy.#s_OFF_API, this.#events || {}, name, callback, {\n         context,\n         eventbus: this.#eventbus,\n      });\n\n      return this;\n   }\n\n   /**\n    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a\n    * large number of different events on a page, the convention is to use colons to namespace them: `poll:start`, or\n    * `change:selection`.\n    *\n    * Please see {@link Eventbus#on}.\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            [context] - Event context.\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut}   [options] - Event registration options.\n    *\n    * @returns {EventbusProxy} This EventbusProxy\n    */\n   on(name, callback, context = void 0, options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      if (options == null || options.constructor !== Object)   // eslint-disable-line eqeqeq\n      {\n         throw new TypeError(`'options' must be an object literal.`);\n      }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- on() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Hang onto the options as s_ON_API sets the context we need to pass to the eventbus in `opts.ctx`.\n      const opts = { context, ctx: this, options };\n\n      this.#events = EventbusUtils.eventsAPI(EventbusProxy.#s_ON_API, this.#events || {}, name, callback, opts);\n\n      this.#eventbus.on(name, callback, opts.ctx, options);\n\n      return this;\n   }\n\n   /**\n    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying \"the next\n    * time that X happens, do this\". When multiple events are passed in using the space separated syntax, the event\n    * will fire once for every event you passed in, not once for a combination of all events\n    *\n    * @param {string|import('.').EventMap}   name - Event name(s) or event map.\n    *\n    * @param {Function|object}   callback - Event callback function or context for event map.\n    *\n    * @param {object}            context - Event context\n    *\n    * @param {import('.').EventOptions | import('.').EventOptionsOut}   [options] - Event registration options.\n    *\n    * @returns {EventbusProxy} This EventbusProxy instance.\n    */\n   once(name, callback, context = void 0, options = {})\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      const data = {};\n      if (this.#eventbus.isGuarded(name, data))\n      {\n         console.warn(`@typhonjs-plugin/eventbus ${EventbusUtils.getErrorName(this)}` +\n          `- once() failed as event name(s) are guarded: ${JSON.stringify(data.names)}`);\n         return this;\n      }\n\n      // Map the event into a `{event: beforeWrapper}` object.\n      const events = EventbusUtils.eventsAPI(EventbusUtils.beforeMap, {}, name, callback,\n       { count: 1, after: this.off.bind(this) });\n\n      if (typeof name === 'string' && (context === null || context === void 0)) { callback = void 0; }\n\n      return this.on(events, callback, context, options);\n   }\n\n   /**\n    * Returns an iterable for all stored locally proxied events yielding an array with event name, callback\n    * function, and event context.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, Function, object, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, Function, object, import('.').EventOptionsOut]}\n    */\n   *proxyEntries(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               for (const event of this.#events[name])\n               {\n                  yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n               }\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            for (const event of this.#events[name])\n            {\n               yield [name, event.callback, event.context, JSON.parse(JSON.stringify(event.options))];\n            }\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields {string}\n    */\n   *proxyKeys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (!this.#events) { return; }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield name;\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield name;\n         }\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of the locally proxied event names with event options.\n    *\n    * Note: The event options returned will respect all the event options from a registered event on the main\n    * eventbus if applicable.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, import('.').EventOptionsOut]}\n    */\n   *proxyKeysWithOptions(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n      if (regex !== void 0 && !(regex instanceof RegExp)) { throw new TypeError(`'regex' is not a RegExp`); }\n\n      if (regex)\n      {\n         for (const name in this.#events)\n         {\n            if (regex.test(name))\n            {\n               yield [name, this.#eventbus.getOptions(name)];\n            }\n         }\n      }\n      else\n      {\n         for (const name in this.#events)\n         {\n            yield [name, this.#eventbus.getOptions(name)];\n         }\n      }\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   trigger(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.trigger(name, ...args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Promise<void|*|*[]>} A Promise returning any results.\n    */\n   triggerAsync(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(name, ...args);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {EventbusProxy} This EventbusProxy.\n    */\n   triggerDefer(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(name, ...args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusProxy instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(name, ...args);\n   }\n\n   // Internal reducer API -------------------------------------------------------------------------------------------\n\n   /**\n    * The reducing API that removes a callback from the `events` object. And delegates invoking off to the eventbus\n    * reference.\n    *\n    * @param {import('.').EventbusEvents}   events - EventbusEvents object\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {void | import('.').EventbusEvents} EventbusEvents object\n    */\n   static #s_OFF_API(events, name, callback, opts)\n   {\n      /* c8 ignore next 1 */\n      if (!events) { return; }\n\n      const context = opts.context;\n      const eventbus = opts.eventbus;\n\n      const names = name ? [name] : EventbusUtils.objectKeys(events);\n\n      for (let i = 0; i < names.length; i++)\n      {\n         name = names[i];\n         const handlers = events[name];\n\n         // Bail out if there are no events stored.\n         if (!handlers) { break; }\n\n         // Find any remaining events.\n         const remaining = [];\n         for (let j = 0; j < handlers.length; j++)\n         {\n            const handler = handlers[j];\n\n            // @ts-ignore\n            if ((callback && callback !== handler.callback && callback !== handler.callback._callback) ||\n             (context && context !== handler.context))\n            {\n               remaining.push(handler);\n               continue;\n            }\n\n            // Must explicitly remove the event by the stored full set of name, handler, context to ensure\n            // non-proxied event registrations are not removed.\n            /* c8 ignore next 1 */ // @ts-ignore\n            eventbus.off(name, handler.callback || handler.callback._callback, handler.context || handler.ctx);\n         }\n\n         // Replace events if there are any remaining.  Otherwise, clean up.\n         if (remaining.length)\n         {\n            events[name] = remaining;\n         }\n         else\n         {\n            // eventbus.off(name, callback, context);\n            delete events[name];\n         }\n      }\n\n      return events;\n   }\n\n   /**\n    * The reducing API that adds a callback to the `events` object.\n    *\n    * @param {import('.').EventbusEvents}   events - EventbusEvents object\n    *\n    * @param {string}   name - Event name\n    *\n    * @param {Function} callback - Event callback\n    *\n    * @param {object}   opts - Optional parameters\n    *\n    * @returns {import('.').EventbusEvents} EventbusEvents object.\n    */\n   static #s_ON_API(events, name, callback, opts)\n   {\n      if (callback)\n      {\n         const handlers = events[name] || (events[name] = []);\n         const context = opts.context, ctx = opts.ctx;\n\n         // Make a copy of options.\n         const options = JSON.parse(JSON.stringify(opts.options));\n\n         // Ensure that guard is set.\n         options.guard = options.guard !== void 0 && typeof options.guard === 'boolean' ? options.guard : false;\n\n         // Determine automatically if the callback is `async` via being defined with the `async` modifier.\n         if (callback instanceof EventbusUtils.AsyncFunction ||\n          callback instanceof EventbusUtils.AsyncGeneratorFunction)\n         {\n            options.type = 2;\n         }\n         else\n         {\n            // Ensure that type is set.\n            switch (options.type)\n            {\n               case 'sync':\n                  options.type = 1;\n                  break;\n               case 'async':\n                  options.type = 2;\n                  break;\n               default:\n                  options.type = 0;\n                  break;\n            }\n         }\n\n         // Set opts `ctx` as this is what we send to the eventbus.\n         opts.ctx = context || ctx;\n\n         handlers.push({ callback, context, ctx: opts.ctx, options });\n      }\n\n      return events;\n   }\n}\n\n/**\n * EventbusSecure provides a secure wrapper around another Eventbus instance.\n *\n * The main use case of EventbusSecure is to provide a secure eventbus window for public consumption. Only\n * events can be triggered, but not registered / unregistered.\n *\n * You must use the initialize method passing in an existing Eventbus instance as the eventbus reference is private.\n * In order to secure the eventbus from unwanted access there is no way to access the eventbus reference externally from\n * the EventbusSecure instance. The initialize method returns an {@link EventbusSecureObj} object which\n * contains two functions to control the secure eventbus externally; `destroy` and `setEventbus`. Expose to end\n * consumers just the `eventbusSecure` instance.\n */\nclass EventbusSecure\n{\n   /**\n    * Stores the target eventbus.\n    *\n    * @type {import('.').Eventbus | import('.').EventbusProxy}\n    */\n   #eventbus;\n\n   /**\n    * Stores a potentially alternate name instead of returning the wrapped Eventbus instance name.\n    *\n    * @type {string}\n    */\n   #name;\n\n   /**\n    * Creates the EventbusSecure instance with an existing instance of Eventbus. An object / EventbusSecureObj is\n    * returned with an EventbusSecure reference and two functions for controlling the underlying Eventbus reference.\n    *\n    * `destroy()` will destroy the underlying Eventbus reference.\n    * `setEventbus(<eventbus>)` will set the underlying reference.\n    *\n    * @param {import('.').Eventbus | import('.').EventbusProxy}  eventbus - The target eventbus instance.\n    *\n    * @param {string}                  [name] - If a name is provided this will be used instead of eventbus name.\n    *\n    * @returns {import('.').EventbusSecureObj} The control object which contains an EventbusSecure reference and\n    *          control functions.\n    */\n   static initialize(eventbus, name = void 0)\n   {\n      if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\n\n      const eventbusSecure = new EventbusSecure();\n      eventbusSecure.#eventbus = eventbus;\n      eventbusSecure.#name = name === void 0 ? eventbus.name : name;\n      Object.seal(eventbusSecure);\n\n      return {\n         destroy: function()\n         {\n            if (!eventbusSecure.isDestroyed)\n            {\n               eventbusSecure.#eventbus = null;\n\n               if (this) { this.eventbusSecure = void 0; }\n            }\n         },\n\n         /**\n          * @param {import('.').Eventbus | import('.').EventbusProxy}   eventbus - Target eventbus.\n          *\n          * @param {string}   [name] - Eventbus name.\n          */\n         setEventbus: function(eventbus, name = void 0)\n         {\n            if (name !== void 0 && typeof name !== 'string') { throw new TypeError(`'name' is not a string.`); }\n\n            if (!eventbusSecure.isDestroyed)\n            {\n               // Adopt the new eventbus name as the current name set matches the wrapped eventbus.\n               if (name === void 0 && eventbusSecure.#name === eventbusSecure.#eventbus.name)\n               {\n                  eventbusSecure.#name = eventbus.name;\n               }\n               else if (name !== void 0)\n               {\n                  eventbusSecure.#name = name;\n               }\n\n               eventbusSecure.#eventbus = eventbus;\n            }\n         },\n\n         eventbusSecure\n      };\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of secured eventbus event listeners.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @yields {string}\n    */\n   *keys(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keys(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns an iterable for the event names / keys of registered event listeners along with event options.\n    *\n    * @param {RegExp} [regex] - Optional regular expression to filter event names.\n    *\n    * @returns {Generator<[string, import('.').EventOptionsOut], void, unknown>} Generator\n    * @yields {[string, import('.').EventOptionsOut]}\n    */\n   *keysWithOptions(regex = void 0)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      for (const entry of this.#eventbus.keysWithOptions(regex))\n      {\n         yield entry;\n      }\n   }\n\n   /**\n    * Returns whether this instance has already been destroyed.\n    *\n    * @returns {boolean} Is destroyed state.\n    */\n   get isDestroyed()\n   {\n      return this.#eventbus === null;\n   }\n\n   /**\n    * Returns the name associated with this instance.\n    *\n    * @returns {string} The target eventbus name.\n    */\n   get name()\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#name;\n   }\n\n   /**\n    * Returns the options of an event name.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {import('.').EventOptionsOut} The event options.\n    */\n   getOptions(name)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.getOptions(name);\n   }\n\n   /**\n    * Returns the trigger type of event name.\n    * Note: if trigger type is not set then undefined is returned for type otherwise 'sync' or 'async' is returned.\n    *\n    * @param {string}   name - Event name(s) to verify.\n    *\n    * @returns {string|undefined} The trigger type.\n    */\n   getType(name)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.getType(name);\n   }\n\n   /**\n    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be\n    * passed along to the event callbacks.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {EventbusSecure} This instance.\n    */\n   trigger(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.trigger(name, ...args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned Promises from invoked targets and returns a\n    * single Promise generated by `Promise.resolve` for a single value or `Promise.all` for multiple results. This is\n    * a very useful mechanism to invoke asynchronous operations over an eventbus.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {Promise<void|*|*[]>} A Promise to returning any results.\n    */\n   triggerAsync(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerAsync(name, ...args);\n   }\n\n   /**\n    * Defers invoking `trigger`. This is useful for triggering events in the next clock tick.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {EventbusSecure} This EventbusProxy.\n    */\n   triggerDefer(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      this.#eventbus.triggerDefer(name, ...args);\n\n      return this;\n   }\n\n   /**\n    * Provides `trigger` functionality, but collects any returned result or results from invoked targets as a single\n    * value or in an array and passes it back to the callee in a synchronous manner.\n    *\n    * @param {string}   name - Event name(s)\n    *\n    * @param {...*}     args - Additional arguments passed to the event function(s).\n    *\n    * @returns {void|*|*[]} An Array of returned results.\n    */\n   triggerSync(name, ...args)\n   {\n      if (this.isDestroyed) { throw new ReferenceError('This EventbusSecure instance has been destroyed.'); }\n\n      return this.#eventbus.triggerSync(name, ...args);\n   }\n}\n\nexport { Eventbus, EventbusProxy, EventbusSecure };\n//# sourceMappingURL=index.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}