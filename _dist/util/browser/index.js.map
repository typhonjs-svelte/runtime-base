{"version":3,"file":"index.js","sources":["../../../src/util/browser/BrowserSupports.js","../../../src/util/browser/CrossWindow.js","../../../src/util/browser/ClipboardAccess.js","../../../src/util/browser/URLParser.js"],"sourcesContent":["/**\r\n * Provides utility methods for checking browser capabilities.\r\n *\r\n * @see https://kilianvalkhof.com/2021/web/detecting-media-query-support-in-css-and-javascript/\r\n *\r\n * @privateRemarks\r\n * TODO: perhaps add support for various standard media query checks for level 4 & 5.\r\n */\r\nexport class BrowserSupports\r\n{\r\n   /**\r\n    * Check for container query support.\r\n    *\r\n    * @returns {boolean} True if container queries supported.\r\n    */\r\n   static get containerQueries()\r\n   {\r\n      return 'container' in document.documentElement.style;\r\n   }\r\n}\r\n","import { isObject } from '#runtime/util/object';\n\n/**\n * Provides cross window checks for DOM nodes / elements, events, and essential duck typing for any class based object\n * with a constructor name. The impetus is that certain browsers such as Chrome and Firefox behave differently when\n * performing `instanceof` checks when elements are moved between browser windows. With Firefox in particular the\n * entire JS runtime can not use `instanceof` checks as the instances of fundamental DOM elements differ between\n * windows.\n *\n * TRL supports moving applications from a main central browser window and popping them out into separate standalone\n * app instances in a separate browser window. In this case for essential DOM element and event checks it is necessary\n * to employ the workarounds found in `CrossWindow`.\n */\nexport class CrossWindow\n{\n   /**\n    * @private\n    */\n   constructor() {} // eslint-disable-line no-useless-constructor\n\n   /**\n    * Class names for all focusable element types.\n    *\n    * @type {string[]}\n    */\n   static #FocusableElementClassNames = ['HTMLAnchorElement', 'HTMLButtonElement', 'HTMLDetailsElement',\n    'HTMLEmbedElement', 'HTMLIFrameElement', 'HTMLInputElement', 'HTMLObjectElement', 'HTMLSelectElement',\n     'HTMLTextAreaElement'];\n\n   /**\n    * DOM nodes with defined `ownerDocument` property.\n    *\n    * @type {Set<number>}\n    */\n   static #NodesWithOwnerDocument = new Set([Node.ELEMENT_NODE, Node.TEXT_NODE, Node.COMMENT_NODE,\n    Node.DOCUMENT_FRAGMENT_NODE]);\n\n   // Various UI Event sets for duck typing by constructor name.\n   /**\n    * Duck typing class names for pointer events.\n    *\n    * @type {Set<string>}\n    */\n   static #PointerEventSet = new Set(['MouseEvent', 'PointerEvent']);\n\n   /**\n    * Duck typing class names for all UIEvents.\n    *\n    * @type {Set<string>}\n    */\n   static #UIEventSet = new Set(['UIEvent', 'FocusEvent', 'MouseEvent', 'WheelEvent', 'KeyboardEvent', 'PointerEvent',\n    'TouchEvent', 'InputEvent', 'CompositionEvent', 'DragEvent']);\n\n   /**\n    * Duck typing class names for events considered as user input.\n    *\n    * @type {Set<string>}\n    */\n   static #UserInputEventSet = new Set(['KeyboardEvent', 'MouseEvent', 'PointerEvent']);\n\n   /**\n    * Internal options used by `#checkDOMInstanceType` when retrieving the Window reference from a Node that doesn't\n    * define `ownerDocument`.\n    *\n    * @type {{throws: boolean}}\n    */\n   static #optionsInternalCheckDOM = { throws: false };\n\n   // DOM Querying ---------------------------------------------------------------------------------------------------\n\n   /**\n    * Convenience method to retrieve the `document.activeElement` value in the current Window context of a DOM Node /\n    * Element, EventTarget, Document, or Window.\n    *\n    * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,\n    *        UIEvent or Window to query.\n    *\n    * @param {object} [options] - Options.\n    *\n    * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the\n    *        target is invalid `undefined` is returned; default: `true`.\n    *\n    * @returns {Element | null} Active element or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getActiveElement(target, { throws = true } = {})\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#NodesWithOwnerDocument.has(target?.nodeType)) { return target?.ownerDocument?.activeElement ?? null; }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target?.view?.document?.activeElement ?? null; }\n\n      // Duck type if target is a Document.\n      if (isObject(target?.defaultView)) { return target?.activeElement ?? null; }\n\n      // Duck type if target is a Window.\n      if (isObject(target?.document) && isObject(target?.location)) { return target?.document?.activeElement ?? null; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   /**\n    * Convenience method to retrieve the `Document` value in the current context of a DOM Node / Element, EventTarget,\n    * Document, UIEvent, or Window.\n    *\n    * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,\n    *        UIEvent or Window to query.\n    *\n    * @param {object} [options] - Options.\n    *\n    * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the\n    *        target is invalid `undefined` is returned; default: `true`.\n    *\n    * @returns {Document} Active document or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getDocument(target, { throws = true } = {})\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#NodesWithOwnerDocument.has(target?.nodeType)) { return target?.ownerDocument; }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target?.view?.document; }\n\n      // Duck type if target is a Document.\n      if (isObject(target?.defaultView)) { return target; }\n\n      // Duck type if target is a Window.\n      if (isObject(target?.document) && isObject(target?.location)) { return target?.document; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   /**\n    * Convenience method to retrieve the `Window` value in the current context of a DOM Node / Element, EventTarget,\n    * Document, or Window.\n    *\n    * @param {Document | EventTarget | Node | UIEvent | Window}  target - DOM Node / Element, EventTarget, Document,\n    *        UIEvent or Window to query.\n    *\n    * @param {object} [options] - Options.\n    *\n    * @param {boolean} [options.throws=true] - When `true` and target is invalid throw an exception. If `false` and the\n    *        target is invalid `undefined` is returned; default: `true`.\n    *\n    * @returns {Window} Active window or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getWindow(target, { throws = true } = {})\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#NodesWithOwnerDocument.has(target?.nodeType))\n      {\n         return target.ownerDocument?.defaultView ?? globalThis;\n      }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target.view ?? globalThis; }\n\n      // Duck type if target is a Document.\n      if (isObject(target?.defaultView)) { return target.defaultView ?? globalThis; }\n\n      // Duck type if target is a Window.\n      if (isObject(target?.document) && isObject(target?.location)) { return target; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   // ES / Browser API basic prototype tests -------------------------------------------------------------------------\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Document.\n    *\n    * @param {unknown}  target - A potential Document to test.\n    *\n    * @returns {target is Document} Is `target` a Document.\n    */\n   static isDocument(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Document]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Map.\n    *\n    * @param {unknown}  target - A potential Map to test.\n    *\n    * @returns {target is Map} Is `target` a Map.\n    */\n   static isMap(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Map]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Promise.\n    *\n    * @param {unknown}  target - A potential Promise to test.\n    *\n    * @returns {target is Promise} Is `target` a Promise.\n    */\n   static isPromise(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Promise]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a RegExp.\n    *\n    * @param {unknown}  target - A potential RegExp to test.\n    *\n    * @returns {target is RegExp} Is `target` a RegExp.\n    */\n   static isRegExp(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object RegExp]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Set.\n    *\n    * @param {unknown}  target - A potential Set to test.\n    *\n    * @returns {target is Set} Is `target` a Set.\n    */\n   static isSet(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Set]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a URL.\n    *\n    * @param {unknown}  target - A potential URL to test.\n    *\n    * @returns {target is URL} Is `target` a URL.\n    */\n   static isURL(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object URL]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Window.\n    *\n    * @param {unknown}  target - A potential Window to test.\n    *\n    * @returns {target is Window} Is `target` a Window.\n    */\n   static isWindow(target)\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Window]';\n   }\n\n   // DOM Element typing ---------------------------------------------------------------------------------------------\n\n   /**\n    * Ensures that the given target is an `instanceof` all known DOM elements that are focusable. Please note that\n    * additional checks are required regarding focusable state; use {@link A11yHelper.isFocusable} for a complete check.\n    *\n    * @param {unknown}  target - Target to test for `instanceof` focusable HTML element.\n    *\n    * @returns {boolean} Is target an `instanceof` a focusable DOM element.\n    */\n   static isFocusableHTMLElement(target)\n   {\n      for (let cntr = this.#FocusableElementClassNames.length; --cntr >= 0;)\n      {\n         if (this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, this.#FocusableElementClassNames[cntr]))\n         {\n            return true;\n         }\n      }\n\n      return false;\n   }\n\n   /**\n    * Provides precise type checking if `target` is a DocumentFragment.\n    *\n    * @param {unknown}  target - A potential DocumentFragment to test.\n    *\n    * @returns {target is DocumentFragment} Is `target` a DocumentFragment.\n    */\n   static isDocumentFragment(target)\n   {\n      return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'DocumentFragment');\n   }\n\n   /**\n    * Provides precise type checking if `target` is an Element.\n    *\n    * @param {unknown}  target - A potential Element to test.\n    *\n    * @returns {target is Element} Is `target` an Element.\n    */\n   static isElement(target)\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'Element');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a HTMLAnchorElement.\n    *\n    * @param {unknown}  target - A potential HTMLAnchorElement to test.\n    *\n    * @returns {target is HTMLAnchorElement} Is `target` a HTMLAnchorElement.\n    */\n   static isHTMLAnchorElement(target)\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLAnchorElement');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a HTMLElement.\n    *\n    * @param {unknown}  target - A potential HTMLElement to test.\n    *\n    * @returns {target is HTMLElement} Is `target` a HTMLElement.\n    */\n   static isHTMLElement(target)\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLElement');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a Node.\n    *\n    * @param {unknown}  target - A potential Node to test.\n    *\n    * @returns {target is Node} Is `target` a DOM Node.\n    */\n   static isNode(target)\n   {\n      if (typeof target?.nodeType !== 'number') { return false; }\n\n      if (target instanceof globalThis.Node) { return true; }\n\n      // Must retrieve window by a more thorough duck type via `getWindow` as not all Nodes have `ownerDocument`\n      // defined.\n      const activeWindow = this.getWindow(target, this.#optionsInternalCheckDOM);\n\n      const TargetNode = activeWindow?.Node;\n      return TargetNode && target instanceof TargetNode;\n   }\n\n   /**\n    * Provides precise type checking if `target` is a ShadowRoot.\n    *\n    * @param {unknown}  target - A potential ShadowRoot to test.\n    *\n    * @returns {target is ShadowRoot} Is `target` a ShadowRoot.\n    */\n   static isShadowRoot(target)\n   {\n      // ShadowRoot is a specialized type of DocumentFragment.\n      return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'ShadowRoot');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a SVGElement.\n    *\n    * @param {unknown}  target - A potential SVGElement to test.\n    *\n    * @returns {target is SVGElement} Is `target` a SVGElement.\n    */\n   static isSVGElement(target)\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'SVGElement');\n   }\n\n   // Event typing ---------------------------------------------------------------------------------------------------\n\n   /**\n    * Provides basic duck type checking for `Event` signature and optional constructor name(s).\n    *\n    * @param {unknown}  target - A potential DOM event to test.\n    *\n    * @param {string | Set<string>} [types] Specific constructor name or Set of constructor names to match.\n    *\n    * @returns {target is Event} Is `target` an Event with optional constructor name check.\n    */\n   static isEvent(target, types)\n   {\n      if (typeof target?.type !== 'string' || typeof target?.defaultPrevented !== 'boolean' ||\n         typeof target?.stopPropagation !== 'function')\n      {\n         return false;\n      }\n\n      return types !== void 0 ? this.isCtorName(target, types) : true;\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for standard mouse / pointer events including\n    * `MouseEvent` and `PointerEvent`.\n    *\n    * @param {unknown}  target - A potential DOM event to test.\n    *\n    * @returns {target is PointerEvent} Is `target` a MouseEvent or PointerEvent.\n    */\n   static isPointerEvent(target)\n   {\n      return this.isEvent(target, this.#PointerEventSet);\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for all UI events.\n    *\n    * @param {unknown}  target - A potential DOM event to test.\n    *\n    * @returns {target is UIEvent} Is `target` a UIEvent.\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent\n    */\n   static isUIEvent(target)\n   {\n      return this.isEvent(target, this.#UIEventSet);\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for standard user input events including `KeyboardEvent`,\n    * `MouseEvent`, and `PointerEvent`.\n    *\n    * @param {unknown}  target - A potential DOM event to test.\n    *\n    * @returns {target is KeyboardEvent | MouseEvent | PointerEvent} Is `target` a Keyboard, MouseEvent, or\n    *          PointerEvent.\n    */\n   static isUserInputEvent(target)\n   {\n      return this.isEvent(target, this.#UserInputEventSet);\n   }\n\n   // Generic typing -------------------------------------------------------------------------------------------------\n\n   /**\n    * Provides basic type checking by constructor name(s) for objects. This can be useful when checking multiple\n    * constructor names against a provided Set.\n    *\n    * @param {unknown}  target - Object to test for constructor name.\n    *\n    * @param {string | Set<string>} types Specific constructor name or Set of constructor names to match.\n    *\n    * @returns {boolean} Does the provided object constructor name match the types provided.\n    */\n   static isCtorName(target, types)\n   {\n      if (!isObject(target)) { return false; }\n\n      if (typeof types === 'string' && target?.constructor?.name === types) { return true; }\n\n      return !!types?.has(target?.constructor?.name);\n   }\n\n   // Internal implementation ----------------------------------------------------------------------------------------\n\n   /**\n    * Internal generic DOM `instanceof` check. First will attempt to find the class name by `globalThis` falling back\n    * to the {@link Window} associated with the DOM node.\n    *\n    * @param {unknown}  target - Target to test.\n    *\n    * @param {number}   nodeType - Node type constant.\n    *\n    * @param {string}   className - DOM class name for instanceof check.\n    *\n    * @returns {boolean} Is the target the given nodeType and instance of class name.\n    */\n   static #checkDOMInstanceType(target, nodeType, className)\n   {\n      if (!isObject(target)) { return false; }\n\n      if (target.nodeType !== nodeType) { return false; }\n\n      const GlobalClass = globalThis[className];\n\n      if (GlobalClass && target instanceof GlobalClass) { return true; }\n\n      const activeWindow = this.#NodesWithOwnerDocument.has(target.nodeType) ? target?.ownerDocument?.defaultView :\n       this.getWindow(target, this.#optionsInternalCheckDOM);\n\n      const TargetClass = activeWindow?.[className];\n\n      return TargetClass && target instanceof TargetClass;\n   }\n}\n","import { CrossWindow } from './CrossWindow.js';\r\n\r\n/**\r\n * Provides access to the Clipboard API for reading / writing text strings. This requires a secure context.\r\n *\r\n * Note: `writeText` will attempt to use the older `execCommand` if available when `navigator.clipboard` is not\r\n * available.\r\n */\r\nexport class ClipboardAccess\r\n{\r\n   /**\r\n    * Uses `navigator.clipboard` if available to read text from the clipboard.\r\n    *\r\n    * Note: Always returns `undefined` when `navigator.clipboard` is not available or the clipboard contains the\r\n    * empty string.\r\n    *\r\n    * @param {Window} [activeWindow=globalThis] Optional active current window.\r\n    *\r\n    * @returns {Promise<string|undefined>} The current clipboard text or undefined.\r\n    */\r\n   static async readText(activeWindow = globalThis)\r\n   {\r\n      let result;\r\n\r\n      if (!CrossWindow.isWindow(activeWindow))\r\n      {\r\n         throw new TypeError(`ClipboardAccess.readText error: 'activeWindow' is not a Window.`);\r\n      }\r\n\r\n      if (activeWindow?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            result = await activeWindow.navigator.clipboard.readText();\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n\r\n      return result === '' ? void 0 : result;\r\n   }\r\n\r\n   /**\r\n    * Uses `navigator.clipboard` if available then falls back to `document.execCommand('copy')` if available to copy\r\n    * the given text to the clipboard.\r\n    *\r\n    * @param {string}   text - Text to copy to the browser clipboard.\r\n    *\r\n    * @param {Window} [activeWindow=globalThis] Optional active current window.\r\n    *\r\n    * @returns {Promise<boolean>} Copy successful.\r\n    */\r\n   static async writeText(text, activeWindow = globalThis)\r\n   {\r\n      if (typeof text !== 'string')\r\n      {\r\n         throw new TypeError(`ClipboardAccess.writeText error: 'text' is not a string.`);\r\n      }\r\n\r\n      if (!CrossWindow.isWindow(activeWindow))\r\n      {\r\n         throw new TypeError(`ClipboardAccess.writeText error: 'activeWindow' is not a Window.`);\r\n      }\r\n\r\n      let success = false;\r\n\r\n      if (activeWindow?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            await activeWindow.navigator.clipboard.writeText(text);\r\n            success = true;\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n      else if (typeof activeWindow?.document?.execCommand === 'function')\r\n      {\r\n         const textArea = activeWindow.document.createElement('textarea');\r\n\r\n         // Place in the top-left corner of screen regardless of scroll position.\r\n         textArea.style.position = 'fixed';\r\n         textArea.style.top = '0';\r\n         textArea.style.left = '0';\r\n\r\n         // Ensure it has a small width and height. Setting to 1px / 1em\r\n         // doesn't work as this gives a negative w/h on some browsers.\r\n         textArea.style.width = '2em';\r\n         textArea.style.height = '2em';\r\n\r\n         // We don't need padding, reducing the size if it does flash render.\r\n         textArea.style.padding = '0';\r\n\r\n         // Clean up any borders.\r\n         textArea.style.border = 'none';\r\n         textArea.style.outline = 'none';\r\n         textArea.style.boxShadow = 'none';\r\n\r\n         // Avoid flash of the white box if rendered for any reason.\r\n         textArea.style.background = 'transparent';\r\n\r\n         textArea.value = text;\r\n\r\n         activeWindow.document.body.appendChild(textArea);\r\n         textArea.focus();\r\n         textArea.select();\r\n\r\n         try\r\n         {\r\n            success = activeWindow.document.execCommand('copy');\r\n         }\r\n         catch (err) { /**/ }\r\n\r\n         activeWindow.document.body.removeChild(textArea);\r\n      }\r\n\r\n      return success;\r\n   }\r\n}\r\n","import { CrossWindow } from './CrossWindow.js';\n\n/**\n * Provides a utility function to parse / construct fully qualified URL instances from a URL string.\n */\nexport class URLParser\n{\n   /**\n    * Parses a URL string converting it to a fully qualified URL. If URL is an existing URL instance it is returned\n    * immediately. Optionally you may construct a fully qualified URL from a relative base origin / path or with a\n    * route prefix added to the current location origin.\n    *\n    * @param {object} options - Options.\n    *\n    * @param {string | URL}   options.url - URL string to convert to a URL.\n    *\n    * @param {string}   [options.base] - Optional fully qualified base path for relative URL construction.\n    *\n    * @param {string}   [options.routePrefix] - Optional route prefix to add to location origin for absolute URL strings\n    *        when `base` is not defined.\n    *\n    * @returns {URL | null} Parsed URL or null if `url` is not parsed.\n    */\n   static parse({ url, base, routePrefix })\n   {\n      if (CrossWindow.isURL(url)) { return url; }\n\n      if (typeof url !== 'string') { return null; }\n\n      if (base !== void 0 && typeof base !== 'string') { return null; }\n\n      if (routePrefix !== void 0 && typeof routePrefix !== 'string') { return null; }\n\n      const targetURL = this.#createURL(url);\n\n      // Parse and return already fully qualified `url` string.\n      if (targetURL) { return targetURL; }\n\n      let targetBase;\n\n      // Parse relative url string.\n      if (url.startsWith('./') || url.startsWith('../'))\n      {\n         // Relative from provided `base` or current path.\n         targetBase = base ? base : `${globalThis.location.origin}${globalThis.location.pathname}`;\n      }\n      else\n      {\n         let targetRoutePrefix = '';\n\n         // Relative to current origin, but include any defined route prefix.\n         if (routePrefix)\n         {\n            // Ensure route prefix starts and ends with `/` for proper URL parsing.\n            targetRoutePrefix = routePrefix.startsWith('/') ? routePrefix : `/${routePrefix}`;\n            targetRoutePrefix = targetRoutePrefix.endsWith('/') ? targetRoutePrefix : `${targetRoutePrefix}/`;\n         }\n\n         targetBase = `${globalThis.location.origin}${targetRoutePrefix}`;\n      }\n\n      return this.#createURL(url, targetBase);\n   }\n\n   // Internal implementation ----------------------------------------------------------------------------------------\n\n   /**\n    * Helper to create a URL and catch any exception. Useful until `URL.parse` and `URL.canParse` are more widespread.\n    *\n    * @param {string}   url - URL string.\n    *\n    * @param {string}   base - Base origin / path.\n    *\n    * @returns {URL | null} Valid URL or null.\n    */\n   static #createURL(url, base = '')\n   {\n      try { return new URL(url, base); }\n      catch(err) { return null; }\n   }\n}\n"],"names":[],"mappings":"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"}