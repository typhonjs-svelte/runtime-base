{"version":3,"file":"index.js","sources":["../../../src/util/browser/CrossWindow.ts","../../../src/util/browser/URLParser.ts","../../../src/util/browser/AssetValidator.ts","../../../src/util/browser/BrowserSupports.ts","../../../src/util/browser/ClipboardAccess.ts"],"sourcesContent":["import { isObject } from '#runtime/util/object';\n\n/**\n * Provides cross-realm checks for DOM nodes / elements, events, and essential duck typing for any class-based object\n * with a constructor name. The impetus is that certain browsers such as Chrome and Firefox behave differently when\n * performing `instanceof` checks when elements are moved between browser windows. With Firefox in particular, the\n * entire JS runtime cannot use `instanceof` checks as the instances of fundamental DOM elements differ between\n * windows.\n *\n * TRL supports moving applications from a main central browser window and popping them out into separate standalone\n * app instances in a separate browser window. In this case, for essential DOM element and event checks, it is necessary\n * to employ the workarounds found in `CrossWindow`.\n */\nclass CrossWindow\n{\n   /**\n    * @private\n    */\n   constructor()\n   {\n      throw new Error('CrossWindow constructor: This is a static class and should not be constructed.');\n   }\n\n   /**\n    * Class names for all focusable element types.\n    */\n   static #FocusableElementClassNames: string[] = ['HTMLAnchorElement', 'HTMLButtonElement', 'HTMLDetailsElement',\n    'HTMLEmbedElement', 'HTMLIFrameElement', 'HTMLInputElement', 'HTMLObjectElement', 'HTMLSelectElement',\n     'HTMLTextAreaElement'];\n\n   /**\n    * DOM nodes with defined `ownerDocument` property.\n    */\n   static #NodesWithOwnerDocument: Set<number> = new Set([Node.ELEMENT_NODE, Node.TEXT_NODE, Node.COMMENT_NODE,\n    Node.DOCUMENT_FRAGMENT_NODE]);\n\n   // Various UIEvent sets for duck typing by constructor name.\n\n   /**\n    * Duck typing class names for pointer events.\n    */\n   static #PointerEventSet: Set<string> = new Set(['MouseEvent', 'PointerEvent']);\n\n   /**\n    * Duck typing class names for all UIEvents.\n    */\n   static #UIEventSet: Set<string> = new Set(['UIEvent', 'FocusEvent', 'MouseEvent', 'WheelEvent', 'KeyboardEvent', 'PointerEvent',\n    'TouchEvent', 'InputEvent', 'CompositionEvent', 'DragEvent']);\n\n   /**\n    * Duck typing class names for events considered as user input.\n    */\n   static #UserInputEventSet: Set<string> = new Set(['KeyboardEvent', 'MouseEvent', 'PointerEvent']);\n\n   /**\n    * Internal options used by `#checkDOMInstanceType` when retrieving the Window reference from a Node that doesn't\n    * define `ownerDocument`.\n    */\n   static #optionsInternalCheckDOM: { throws: boolean } = { throws: false };\n\n   // DOM Querying ---------------------------------------------------------------------------------------------------\n\n   /**\n    * Convenience method to test if the given target element is the current active element.\n    *\n    * @param target - Element to test as current active element.\n    */\n   static isActiveElement(target: Element): boolean\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#hasOwnerDocument(target))\n      {\n         return target?.ownerDocument?.activeElement === target;\n      }\n\n      return false;\n   }\n\n   /**\n    * Convenience method to retrieve the `document.activeElement` value in the current Window context of a DOM Node /\n    * Element, EventTarget, Document, or Window.\n    *\n    * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n    *\n    * @param [options] - Options.\n    *\n    * @returns Active element or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getActiveElement(target: CrossWindow.GetTarget, { throws = true }: CrossWindow.GetOptions = {}): Element |\n    null | undefined\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#hasOwnerDocument(target)) { return target?.ownerDocument?.activeElement ?? null; }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target?.view?.document?.activeElement ?? null; }\n\n      // Duck type if target is a Document.\n      if (this.isDocument(target)) { return target?.activeElement ?? null; }\n\n      // Duck type if target is a Window.\n      if (this.isWindow(target)) { return target?.document?.activeElement ?? null; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   /**\n    * Convenience method to retrieve the `Document` value in the current context of a DOM Node / Element, EventTarget,\n    * Document, UIEvent, or Window.\n    *\n    * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n    *\n    * @param [options] - Options.\n    *\n    * @returns {Document} Active document or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getDocument(target: CrossWindow.GetTarget, { throws = true } = {}): Document | undefined\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#hasOwnerDocument(target)) { return target?.ownerDocument; }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target?.view?.document; }\n\n      // Duck type if target is a Document.\n      if (this.isDocument(target)) { return target; }\n\n      // Duck type if target is a Window.\n      if (this.isWindow(target)) { return target?.document; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   /**\n    * Convenience method to retrieve the `Window` value in the current context of a DOM Node / Element, EventTarget,\n    * Document, or Window.\n    *\n    * @param target - DOM Node / Element, EventTarget, Document, UIEvent or Window to query.\n    *\n    * @param [options] - Options.\n    *\n    * @returns Active window or `undefined` when `throws` option is `false` and the target is invalid.\n    *\n    * @throws {@link TypeError} Target must be a DOM Node / Element, Document, UIEvent, or Window.\n    */\n   static getWindow(target: CrossWindow.GetTarget, { throws = true } = {}): Window | undefined\n   {\n      // Duck type if target has known defined `ownerDocument` property.\n      if (this.#hasOwnerDocument(target)) { return target.ownerDocument?.defaultView ?? globalThis as typeof window; }\n\n      // Duck type if target is a UIEvent.\n      if (this.isUIEvent(target) && isObject(target?.view)) { return target.view ?? globalThis as typeof window; }\n\n      // Duck type if target is a Document.\n      if (this.isDocument(target)) { return target.defaultView ?? globalThis as typeof window; }\n\n      // Duck type if target is a Window.\n      if (this.isWindow(target)) { return target; }\n\n      if (throws) { throw new TypeError(`'target' must be a DOM Node / Element, Document, UIEvent, or Window.`); }\n\n      return void 0;\n   }\n\n   // ES / Browser API basic prototype tests -------------------------------------------------------------------------\n\n   /**\n    * Provides basic prototype string type checking if `target` is a CSSImportRule.\n    *\n    * @param target - A potential CSSImportRule to test.\n    *\n    * @returns Is `target` a CSSImportRule.\n    */\n   static isCSSImportRule(target: unknown): target is CSSImportRule\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object CSSImportRule]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a CSSLayerBlockRule.\n    *\n    * @param target - A potential CSSLayerBlockRule to test.\n    *\n    * @returns Is `target` a CSSLayerBlockRule.\n    */\n   static isCSSLayerBlockRule(target: unknown): target is CSSLayerBlockRule\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object CSSLayerBlockRule]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a CSSStyleRule.\n    *\n    * @param target - A potential CSSStyleRule to test.\n    *\n    * @returns Is `target` a CSSStyleRule.\n    */\n   static isCSSStyleRule(target: unknown): target is CSSStyleRule\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object CSSStyleRule]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a CSSStyleSheet.\n    *\n    * @param target - A potential CSSStyleSheet to test.\n    *\n    * @returns Is `target` a CSSStyleSheet.\n    */\n   static isCSSStyleSheet(target: unknown): target is CSSStyleSheet\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object CSSStyleSheet]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Document.\n    *\n    * @param target - A potential Document to test.\n    *\n    * @returns Is `target` a Document.\n    */\n   static isDocument(target: unknown): target is Document\n   {\n      // Match any DOM Document object by its default @@toStringTag.\n      // - HTMLDocument (`[object HTMLDocument]` in modern browsers & JSDOM)\n      // - generic Document (`[object Document]` in older or XML contexts)\n      return isObject(target) && /^\\[object (HTML)?Document]$/.test(Object.prototype.toString.call(target));\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Map.\n    *\n    * @param target - A potential Map to test.\n    *\n    * @returns Is `target` a Map.\n    */\n   static isMap(target: unknown): target is Map<unknown, unknown>\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Map]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Promise.\n    *\n    * @param target - A potential Promise to test.\n    *\n    * @returns Is `target` a Promise.\n    */\n   static isPromise(target: unknown): target is Promise<unknown>\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Promise]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a RegExp.\n    *\n    * @param target - A potential RegExp to test.\n    *\n    * @returns Is `target` a RegExp.\n    */\n   static isRegExp(target: unknown): target is RegExp\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object RegExp]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Set.\n    *\n    * @param target - A potential Set to test.\n    *\n    * @returns Is `target` a Set.\n    */\n   static isSet(target: unknown): target is Set<unknown>\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Set]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a URL.\n    *\n    * @param target - A potential URL to test.\n    *\n    * @returns Is `target` a URL.\n    */\n   static isURL(target: unknown): target is URL\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object URL]';\n   }\n\n   /**\n    * Provides basic prototype string type checking if `target` is a Window.\n    *\n    * @param target - A potential Window to test.\n    *\n    * @returns Is `target` a Window.\n    */\n   static isWindow(target: unknown): target is Window\n   {\n      return isObject(target) && Object.prototype.toString.call(target) === '[object Window]';\n   }\n\n   // DOM Element typing ---------------------------------------------------------------------------------------------\n\n   /**\n    * Ensures that the given target is an `instanceof` all known DOM elements that are focusable. Please note that\n    * additional checks are required regarding focusable state; use {@link A11yHelper.isFocusable} for a complete check.\n    *\n    * @param target - Target to test for `instanceof` focusable HTML element.\n    *\n    * @returns Is target an `instanceof` a focusable DOM element.\n    */\n   static isFocusableHTMLElement(target: unknown): boolean\n   {\n      for (let cntr = this.#FocusableElementClassNames.length; --cntr >= 0;)\n      {\n         if (this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, this.#FocusableElementClassNames[cntr]))\n         {\n            return true;\n         }\n      }\n\n      return false;\n   }\n\n   /**\n    * Provides precise type checking if `target` is a DocumentFragment.\n    *\n    * @param target - A potential DocumentFragment to test.\n    *\n    * @returns Is `target` a DocumentFragment.\n    */\n   static isDocumentFragment(target: unknown): target is DocumentFragment\n   {\n      return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'DocumentFragment');\n   }\n\n   /**\n    * Provides precise type checking if `target` is an Element.\n    *\n    * @param target - A potential Element to test.\n    *\n    * @returns Is `target` an Element.\n    */\n   static isElement(target: unknown): target is Element\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'Element');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a HTMLAnchorElement.\n    *\n    * @param target - A potential HTMLAnchorElement to test.\n    *\n    * @returns Is `target` a HTMLAnchorElement.\n    */\n   static isHTMLAnchorElement(target: unknown): target is HTMLAnchorElement\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLAnchorElement');\n   }\n\n   /**\n    * Provides precise type checking if `target` is an HTMLElement.\n    *\n    * @param target - A potential HTMLElement to test.\n    *\n    * @returns Is `target` a HTMLElement.\n    */\n   static isHTMLElement(target: unknown): target is HTMLElement\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'HTMLElement');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a Node.\n    *\n    * @param target - A potential Node to test.\n    *\n    * @returns Is `target` a DOM Node.\n    */\n   static isNode(target: unknown): target is Node\n   {\n      if (typeof (target as Node)?.nodeType !== 'number') { return false; }\n\n      if (target instanceof globalThis.Node) { return true; }\n\n      // Must retrieve the window by a more thorough duck type via `getWindow` as not all Nodes have `ownerDocument`\n      // defined.\n      const activeWindow = this.getWindow(target as Window, this.#optionsInternalCheckDOM);\n\n      const TargetNode = (activeWindow as typeof window)?.Node;\n      return TargetNode && target instanceof TargetNode;\n   }\n\n   /**\n    * Provides precise type checking if `target` is a ShadowRoot.\n    *\n    * @param target - A potential ShadowRoot to test.\n    *\n    * @returns Is `target` a ShadowRoot.\n    */\n   static isShadowRoot(target: unknown): target is ShadowRoot\n   {\n      // ShadowRoot is a specialized type of DocumentFragment.\n      return this.#checkDOMInstanceType(target, Node.DOCUMENT_FRAGMENT_NODE, 'ShadowRoot');\n   }\n\n   /**\n    * Provides precise type checking if `target` is a SVGElement.\n    *\n    * @param target - A potential SVGElement to test.\n    *\n    * @returns Is `target` a SVGElement.\n    */\n   static isSVGElement(target: unknown): target is SVGElement\n   {\n      return this.#checkDOMInstanceType(target, Node.ELEMENT_NODE, 'SVGElement');\n   }\n\n   // Event typing ---------------------------------------------------------------------------------------------------\n\n   /**\n    * Provides basic duck type checking for `Event` signature and optional constructor name(s).\n    *\n    * @param target - A potential DOM event to test.\n    *\n    * @param [types] Specific constructor name or Set of constructor names to match.\n    *\n    * @returns Is `target` an Event with optional constructor name check.\n    */\n   static isEvent(target: unknown, types: string | Set<string>): target is Event\n   {\n      if (typeof (target as Event)?.type !== 'string' || typeof (target as Event)?.defaultPrevented !== 'boolean' ||\n       typeof (target as Event)?.stopPropagation !== 'function')\n      {\n         return false;\n      }\n\n      return types !== void 0 ? this.isCtorName(target, types) : true;\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for standard mouse / pointer events including\n    * `MouseEvent` and `PointerEvent`.\n    *\n    * @param target - A potential DOM event to test.\n    *\n    * @returns Is `target` a MouseEvent or PointerEvent.\n    */\n   static isPointerEvent(target: unknown): target is PointerEvent\n   {\n      return this.isEvent(target, this.#PointerEventSet);\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for all UI events.\n    *\n    * @param target - A potential DOM event to test.\n    *\n    * @returns Is `target` a UIEvent.\n    * @see https://developer.mozilla.org/en-US/docs/Web/API/UIEvent\n    */\n   static isUIEvent(target: unknown): target is UIEvent\n   {\n      return this.isEvent(target, this.#UIEventSet);\n   }\n\n   /**\n    * Provides basic duck type checking for `Event` signature for standard user input events including `KeyboardEvent`,\n    * `MouseEvent`, and `PointerEvent`.\n    *\n    * @param target - A potential DOM event to test.\n    *\n    * @returns Is `target` a Keyboard, MouseEvent, or PointerEvent.\n    */\n   static isUserInputEvent(target: unknown): target is KeyboardEvent | MouseEvent | PointerEvent\n   {\n      return this.isEvent(target, this.#UserInputEventSet);\n   }\n\n   // Generic typing -------------------------------------------------------------------------------------------------\n\n   /**\n    * Provides basic type checking by constructor name(s) for objects. This can be useful when checking multiple\n    * constructor names against a provided Set.\n    *\n    * @param target - Object to test for constructor name.\n    *\n    * @param types Specific constructor name or Set of constructor names to match.\n    *\n    * @returns Does the provided object constructor name match the types provided.\n    */\n   static isCtorName(target: unknown, types: string | Set<string>): boolean\n   {\n      if (!isObject(target)) { return false; }\n\n      if (typeof types === 'string' && target?.constructor?.name === types) { return true; }\n\n      return !!(types as Set<string>)?.has(target?.constructor?.name);\n   }\n\n   // Internal implementation ----------------------------------------------------------------------------------------\n\n   /**\n    * Internal generic DOM `instanceof` check. First will attempt to find the class name by `globalThis` falling back\n    * to the {@link Window} associated with the DOM node.\n    *\n    * @param target - Target to test.\n    *\n    * @param nodeType - Node type constant.\n    *\n    * @param className - DOM classname for instanceof check.\n    *\n    * @returns Is the target the given nodeType and instance of class name.\n    */\n   static #checkDOMInstanceType(target: unknown, nodeType: number, className: string): boolean\n   {\n      if (!isObject(target)) { return false; }\n\n      if (target.nodeType !== nodeType) { return false; }\n\n      const GlobalClass: any = (window as unknown as Record<string, unknown>)[className];\n\n      if (GlobalClass && target instanceof GlobalClass) { return true; }\n\n      const activeWindow: Window | undefined | null = this.#hasOwnerDocument(target) ?\n         target?.ownerDocument?.defaultView :\n         // @ts-ignore: Safe in this context.\n         this.getWindow(target, this.#optionsInternalCheckDOM);\n\n      const TargetClass: any = (activeWindow as unknown as Record<string, unknown>)?.[className];\n\n      return TargetClass && target instanceof TargetClass;\n   }\n\n   static #hasOwnerDocument(target: unknown): target is Element\n   {\n      return typeof target === 'object' && target !== null &&\n       this.#NodesWithOwnerDocument.has((target as Node)?.nodeType);\n   }\n}\n\ndeclare namespace CrossWindow {\n\n   /**\n    * Defines the DOM API targets usable for all `get` methods.\n    */\n   export type GetTarget = Document | EventTarget | Node | UIEvent | Window;\n\n   /**\n    * Defines options for all `get` methods.\n    */\n   export interface GetOptions {\n      /**\n       * When `true` and the target is invalid, throw an exception. If `false` and the target is invalid `undefined`\n       * is returned; default: `true`.\n       *\n       * @defaultValue `true`\n       */\n      throws?: boolean;\n   }\n}\n\nexport { CrossWindow }\n","import { CrossWindow } from './CrossWindow';\n\n/**\n * Provides a utility function to parse / construct fully qualified URL instances from a URL string.\n */\nexport class URLParser\n{\n   /**\n    * @private\n    */\n   constructor()\n   {\n      throw new Error('URLParser constructor: This is a static class and should not be constructed.');\n   }\n\n   /**\n    * Parses a URL string converting it to a fully qualified URL. If URL is an existing URL instance, it is returned\n    * immediately. Optionally, you may construct a fully qualified URL from a relative base origin / path or with a\n    * route prefix added to the current location origin.\n    *\n    * @param options - Options.\n    *\n    * @param options.url - URL string to convert to a URL.\n    *\n    * @param [options.base] - Optional fully qualified base path for relative URL construction.\n    *\n    * @param [options.routePrefix] - Optional route prefix to add to location origin for absolute URL strings\n    *        when `base` is not defined.\n    *\n    * @returns Parsed URL or null if `url` is not parsed.\n    */\n   static parse({ url, base, routePrefix }: { url: string | URL, base?: string, routePrefix?: string }): URL | null\n   {\n      if (CrossWindow.isURL(url)) { return url; }\n\n      if (typeof url !== 'string') { return null; }\n\n      if (base !== void 0 && typeof base !== 'string') { return null; }\n\n      if (routePrefix !== void 0 && typeof routePrefix !== 'string') { return null; }\n\n      const targetURL = this.#createURL(url);\n\n      // Parse and return already fully qualified `url` string.\n      if (targetURL) { return targetURL; }\n\n      let targetBase;\n\n      // Parse relative url string.\n      if (url.startsWith('./') || url.startsWith('../'))\n      {\n         // Relative from provided `base` or current path.\n         targetBase = base ? base : `${globalThis.location.origin}${globalThis.location.pathname}`;\n      }\n      else\n      {\n         let targetRoutePrefix = '';\n\n         // Relative to current origin, but include any defined route prefix.\n         if (routePrefix)\n         {\n            // Ensure route prefix starts and ends with `/` for proper URL parsing.\n            targetRoutePrefix = routePrefix.startsWith('/') ? routePrefix : `/${routePrefix}`;\n            targetRoutePrefix = targetRoutePrefix.endsWith('/') ? targetRoutePrefix : `${targetRoutePrefix}/`;\n         }\n\n         targetBase = `${globalThis.location.origin}${targetRoutePrefix}`;\n      }\n\n      return this.#createURL(url, targetBase);\n   }\n\n   // Internal implementation ----------------------------------------------------------------------------------------\n\n   /**\n    * Helper to create a URL and catch any exception. Useful until `URL.parse` and `URL.canParse` are more widespread.\n    *\n    * @param url - URL string.\n    *\n    * @param base - Base origin / path.\n    *\n    * @returns Valid URL or null.\n    */\n   static #createURL(url: string, base: string = ''): URL | null\n   {\n      try { return new URL(url, base); }\n      catch(err) { return null; }\n   }\n}\n","import { Frozen }       from '#runtime/util';\n\nimport { CrossWindow }  from './CrossWindow';\n\nimport { URLParser }    from './URLParser';\n\n/**\n * Provides a utility to validate media file types and determine the appropriate HTML element type for rendering.\n */\nclass AssetValidator\n{\n   /** Default media types. */\n   static #mediaTypes: AssetValidator.DefaultMediaTypes = Object.freeze({\n      all: Frozen.Set<AssetValidator.Options.MediaTypes>(['audio', 'img', 'svg', 'video']),\n      audio: Frozen.Set<AssetValidator.Options.MediaTypes>(['audio']),\n      img: Frozen.Set<AssetValidator.Options.MediaTypes>(['img']),\n      img_svg: Frozen.Set<AssetValidator.Options.MediaTypes>(['img', 'svg']),\n      img_svg_video: Frozen.Set<AssetValidator.Options.MediaTypes>(['img', 'svg', 'video']),\n      video: Frozen.Set<AssetValidator.Options.MediaTypes>(['video']),\n   });\n\n   /** Supported audio extensions. */\n   static #audioExtensions = new Set(['mp3', 'wav', 'ogg', 'aac', 'flac', 'webm']);\n\n   /** Supported image extensions. */\n   static #imageExtensions = new Set(['jpg', 'jpeg', 'png', 'gif', 'bmp', 'svg', 'webp']);\n\n   /** Supported SVG extensions. */\n   static #svgExtensions = new Set(['svg']);\n\n   /** Supported video extensions. */\n   static #videoExtensions = new Set(['mp4', 'webm', 'ogg']);\n\n   /**\n    * @private\n    */\n   constructor()\n   {\n      throw new Error('AssetValidator constructor: This is a static class and should not be constructed.');\n   }\n\n   /**\n    * Provides several readonly default media type Sets useful for the `mediaTypes` option.\n    */\n   static get MediaTypes(): AssetValidator.DefaultMediaTypes\n   {\n      return this.#mediaTypes;\n   }\n\n   /**\n    * Parses the provided file path to determine the media type and validity based on the file extension. Certain\n    * extensions can be excluded in addition to filtering by specified media types.\n    *\n    * @param options - Options.\n    *\n    * @returns The parsed asset information containing the file path, extension, element type, and whether the parsing\n    *          is valid for the file extension is supported and not excluded.\n    *\n    * @throws {TypeError} If the provided `url` is not a string or URL, `routePrefix` is not a string,\n    *         `exclude` is not a Set, or `mediaTypes` is not a Set.\n    */\n   static parseMedia({ url, routePrefix, exclude, mediaTypes = this.#mediaTypes.all, raiseException = false }:\n    AssetValidator.Options.ParseMedia): AssetValidator.Data.ParsedMediaResult\n   {\n      const throws = typeof raiseException === 'boolean' ? raiseException : true;\n\n      if (typeof url !== 'string' && !CrossWindow.isURL(url))\n      {\n         if (throws) { throw new TypeError(`'url' is not a string or URL instance.`); }\n         else { return { url, valid: false }; }\n      }\n\n      if (routePrefix !== void 0 && typeof routePrefix !== 'string')\n      {\n         if (throws) { throw new TypeError(`'routePrefix' is not a string.`); }\n         else { return { url, valid: false }; }\n      }\n\n      if (exclude !== void 0 && !CrossWindow.isSet(exclude))\n      {\n         if (throws) { throw new TypeError(`'exclude' is not a Set.`); }\n         else { return { url, valid: false }; }\n      }\n\n      if (!CrossWindow.isSet(mediaTypes))\n      {\n         if (throws) { throw new TypeError(`'mediaTypes' is not a Set.`); }\n         else { return { url, valid: false }; }\n      }\n\n      const targetURL = typeof url === 'string' ? URLParser.parse({ url, routePrefix }) : url;\n\n      if (!targetURL)\n      {\n         if (throws) { throw new TypeError(`'url' is invalid.`); }\n         else { return { url, valid: false }; }\n      }\n\n      const extensionMatch = targetURL.pathname.match(/\\.([a-zA-Z0-9]+)$/);\n      const extension = extensionMatch ? extensionMatch[1].toLowerCase() : void 0;\n\n      const isExcluded = extension && CrossWindow.isSet(exclude) ? exclude.has(extension) : false;\n\n      let elementType: 'img' | 'video' | 'svg' | 'audio' | undefined = void 0;\n      let valid = false;\n\n      if (extension && !isExcluded)\n      {\n         if (this.#svgExtensions.has(extension) && mediaTypes.has('svg'))\n         {\n            elementType = 'svg';\n            valid = true;\n         }\n         else if (this.#imageExtensions.has(extension) && mediaTypes.has('img'))\n         {\n            elementType = 'img';\n            valid = true;\n         }\n         else if (this.#videoExtensions.has(extension) && mediaTypes.has('video'))\n         {\n            elementType = 'video';\n            valid = true;\n         }\n         else if (this.#audioExtensions.has(extension) && mediaTypes.has('audio'))\n         {\n            elementType = 'audio';\n            valid = true;\n         }\n      }\n\n      return valid ? {\n         src: url,\n         url: targetURL,\n         extension,\n         elementType,\n         valid\n      } : { url, valid: false };\n   }\n}\n\nObject.freeze(AssetValidator);\n\n/**\n * Defines various options and data types for {@link AssetValidator}.\n */\ndeclare namespace AssetValidator {\n   /**\n    * Provides several default {@link AssetValidator.Options.MediaTypes} Sets that are commonly used.\n    */\n   export type DefaultMediaTypes = Readonly<{\n      /**\n       * All supported media types 'audio' | 'img' | 'svg' | 'video'.\n       */\n      all: ReadonlySet<AssetValidator.Options.MediaTypes>;\n\n      /**\n       * Only media type 'audio'.\n       */\n      audio: ReadonlySet<AssetValidator.Options.MediaTypes>;\n\n      /**\n       * Only media type 'img'.\n       */\n      img: ReadonlySet<AssetValidator.Options.MediaTypes>;\n\n      /**\n       * Only media types 'img' | 'svg'.\n       */\n      img_svg: ReadonlySet<AssetValidator.Options.MediaTypes>;\n\n      /**\n       * Only media types 'img' | 'svg' | 'video'.\n       */\n\n      img_svg_video: ReadonlySet<AssetValidator.Options.MediaTypes>;\n\n      /**\n       * Only media type 'video'.\n       */\n      video: ReadonlySet<AssetValidator.Options.MediaTypes>;\n   }>;\n\n   export namespace Options {\n      /**\n       * Valid media types to parse / define for {@link AssetValidator.parseMedia}`.\n       */\n      export type MediaTypes = 'audio' | 'img' | 'svg' | 'video';\n\n      /**\n       * Options for {@link AssetValidator.parseMedia}.\n       */\n      export interface ParseMedia {\n         /**\n          * The URL of the media asset to validate.\n          */\n         url: string | URL;\n\n         /**\n          * A set of file extensions to exclude from validation.\n          */\n         exclude?: Set<string>;\n\n         /**\n          * A set of media types to validate against including: `audio`, `img`, `svg`, `video`.\n          *\n          * @defaultValue `'audio', 'img', 'svg', 'video'`\n          */\n         mediaTypes?: ReadonlySet<MediaTypes> | Set<MediaTypes>;\n\n         /**\n          * When true exceptions are thrown.\n          *\n          * @defaultValue `false`\n          */\n         raiseException?: boolean;\n\n         /**\n          * An additional route / URL prefix to add in constructing URL.\n          */\n         routePrefix?: string;\n      }\n   }\n\n   export namespace Data {\n      /**\n       * A non-valid parse media result.\n       */\n      export type InvalidMediaResult = {\n         /**\n          * Original URL.\n          */\n         url: string | URL;\n\n         /**\n          * Extension type\n          */\n         extension?: undefined;\n\n         /**\n          * Key to indicate which element should render the URL.\n          */\n         elementType?: undefined;\n\n         /**\n          * Result indicating invalid.\n          */\n         valid: false;\n      };\n\n      /**\n       * A valid parse media result.\n       */\n      export type ValidMediaResult = {\n         /**\n          * Original URL.\n          */\n         src: string | URL;\n\n         /**\n          * Parsed URL.\n          */\n         url: URL;\n\n         /**\n          * Extension type\n          */\n         extension?: string;\n\n         /**\n          * Key to indicate which element should render the URL.\n          */\n         elementType?: 'img' | 'video' | 'svg' | 'audio';\n\n         /**\n          * Result indicating valid.\n          */\n         valid: true;\n      };\n\n      /**\n       * The `parseMedia` result indicating either a valid / non-valid parse attempt.\n       */\n      export type ParsedMediaResult = ValidMediaResult | InvalidMediaResult;\n   }\n}\n\nexport { AssetValidator }\n","/**\r\n * Provides utility methods for checking browser capabilities.\r\n *\r\n * @see https://kilianvalkhof.com/2021/web/detecting-media-query-support-in-css-and-javascript/\r\n *\r\n * @privateRemarks\r\n * TODO: perhaps add support for various standard media query checks for level 4 & 5.\r\n */\r\nexport class BrowserSupports\r\n{\r\n   /**\r\n    * @private\r\n    */\r\n   constructor()\r\n   {\r\n      throw new Error('BrowserSupports constructor: This is a static class and should not be constructed.');\r\n   }\r\n\r\n   /**\r\n    * Check for container query support.\r\n    *\r\n    * @returns True if container queries supported.\r\n    */\r\n   static get containerQueries(): boolean\r\n   {\r\n      return 'container' in document.documentElement.style;\r\n   }\r\n}\r\n","import { CrossWindow } from './CrossWindow';\r\n\r\n/**\r\n * Provides access to the Clipboard API for reading / writing text strings. This requires a secure context.\r\n *\r\n * Note: `writeText` will attempt to use the older `execCommand` if available when `navigator.clipboard` is not\r\n * available.\r\n */\r\nexport class ClipboardAccess\r\n{\r\n   /**\r\n    * @private\r\n    */\r\n   constructor()\r\n   {\r\n      throw new Error('ClipboardAccess constructor: This is a static class and should not be constructed.');\r\n   }\r\n\r\n   /**\r\n    * Uses `navigator.clipboard` if available to read text from the clipboard.\r\n    *\r\n    * Note: Always returns `undefined` when `navigator.clipboard` is not available or the clipboard contains the\r\n    * empty string.\r\n    *\r\n    * @param [activeWindow=window] Optional active current window.\r\n    *\r\n    * @returns {Promise<string|undefined>} The current clipboard text or undefined.\r\n    */\r\n   static async readText(activeWindow: Window = window): Promise<string | undefined>\r\n   {\r\n      let result: string = '';\r\n\r\n      if (!CrossWindow.isWindow(activeWindow))\r\n      {\r\n         throw new TypeError(`ClipboardAccess.readText error: 'activeWindow' is not a Window.`);\r\n      }\r\n\r\n      if (activeWindow?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            result = await activeWindow.navigator.clipboard.readText();\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n\r\n      return result === '' ? void 0 : result;\r\n   }\r\n\r\n   /**\r\n    * Uses `navigator.clipboard` if available then falls back to `document.execCommand('copy')` if available to copy\r\n    * the given text to the clipboard.\r\n    *\r\n    * @param text - Text to copy to the browser clipboard.\r\n    *\r\n    * @param [activeWindow=window] Optional active current window.\r\n    *\r\n    * @returns Copy successful.\r\n    */\r\n   static async writeText(text: string, activeWindow: Window = window): Promise<boolean>\r\n   {\r\n      if (typeof text !== 'string')\r\n      {\r\n         throw new TypeError(`ClipboardAccess.writeText error: 'text' is not a string.`);\r\n      }\r\n\r\n      if (!CrossWindow.isWindow(activeWindow))\r\n      {\r\n         throw new TypeError(`ClipboardAccess.writeText error: 'activeWindow' is not a Window.`);\r\n      }\r\n\r\n      let success = false;\r\n\r\n      if (activeWindow?.navigator?.clipboard)\r\n      {\r\n         try\r\n         {\r\n            await activeWindow.navigator.clipboard.writeText(text);\r\n            success = true;\r\n         }\r\n         catch (err) { /**/ }\r\n      }\r\n      else if (typeof activeWindow?.document?.execCommand === 'function')\r\n      {\r\n         const textArea = activeWindow.document.createElement('textarea');\r\n\r\n         // Place in the top-left corner of the screen regardless of scroll position.\r\n         textArea.style.position = 'fixed';\r\n         textArea.style.top = '0';\r\n         textArea.style.left = '0';\r\n\r\n         // Ensure it has a small width and height. Setting to 1px / 1em\r\n         // doesn't work as this gives a negative w/h on some browsers.\r\n         textArea.style.width = '2em';\r\n         textArea.style.height = '2em';\r\n\r\n         // We don't need padding, reducing the size if it does flash render.\r\n         textArea.style.padding = '0';\r\n\r\n         // Clean up any borders.\r\n         textArea.style.border = 'none';\r\n         textArea.style.outline = 'none';\r\n         textArea.style.boxShadow = 'none';\r\n\r\n         // Avoid the flash of the white box if rendered for any reason.\r\n         textArea.style.background = 'transparent';\r\n\r\n         textArea.value = text;\r\n\r\n         activeWindow.document.body.appendChild(textArea);\r\n         textArea.focus();\r\n         textArea.select();\r\n\r\n         try\r\n         {\r\n            success = activeWindow.document.execCommand('copy');\r\n         }\r\n         catch (err) { /**/ }\r\n\r\n         activeWindow.document.body.removeChild(textArea);\r\n      }\r\n\r\n      return success;\r\n   }\r\n}\r\n"],"names":[],"mappings":"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"}