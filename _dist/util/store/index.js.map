{"version":3,"file":"index.js","sources":["../../../src/util/store/index.js"],"sourcesContent":["/**\n * Provides a basic test for a given variable to test if it has the shape of a readable store by having a `subscribe`\n * function.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ a `subscribe` function.\n *\n * @param {*}  store - variable to test that might be a store.\n *\n * @returns {boolean} Whether the variable tested has the shape of a store.\n */\nexport function isReadableStore(store)\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof store.subscribe === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Provides a basic test for a given variable to test if it has the shape of a writable store by having a `subscribe`\n * function and an `update` function.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ a `subscribe` function.\n *\n * @param {*}  store - variable to test that might be a store.\n *\n * @returns {boolean} Whether the variable tested has the shape of a store.\n */\nexport function isUpdatableStore(store)\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof store.subscribe === 'function' && typeof store.update === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Provides a basic test for a given variable to test if it has the shape of a writable store by having a `subscribe`\n * `set`, and `update` functions.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ `subscribe` & `set` functions.\n *\n * @param {*}  store - variable to test that might be a store.\n *\n * @returns {boolean} Whether the variable tested has the shape of a store.\n */\nexport function isWritableStore(store)\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof store.subscribe === 'function' && typeof store.set === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Wraps a writable stores set method invoking a callback after the store is set. This allows hard coupled parent /\n * child relationships between stores to update directly without having to subscribe to the child store. This is a\n * particular powerful pattern when the `setCallback` is a debounced function that syncs a parent store and / or\n * serializes data.\n *\n * Note: Do consider carefully if this is an optimum solution; this is a quick implementation helper, but a better\n * solution is properly managing store relationships through subscription.\n *\n * @template T\n *\n * @param {import('svelte/store').Writable<T>} store - A store to wrap.\n *\n * @param {(store?: import('svelte/store').Writable<T>, value?: T) => void} setCallback - A callback to invoke after\n *        store set.\n *\n * @returns {import('svelte/store').Writable<T>} Wrapped store.\n */\nexport function storeCallback(store, setCallback)\n{\n   if (!isWritableStore(store)) { throw new TypeError(`'store' is not a writable store.`); }\n   if (typeof setCallback !== 'function') { throw new TypeError(`'setCallback' is not a function.`); }\n\n   /** @type {import('svelte/store').Writable<T>} */\n   return {\n      set: (value) =>\n      {\n         store.set(value);\n         setCallback(store, value);\n      },\n\n      subscribe: store.subscribe,\n\n      update: typeof store.update === 'function' ? store.update : void 0\n   };\n}\n\n/**\n * Subscribes to the given store with the update function provided and ignores the first automatic\n * update. All future updates are dispatched to the update function.\n *\n * @param {import('svelte/store').Readable | import('svelte/store').Writable} store -\n *  Store to subscribe to...\n *\n * @param {import('svelte/store').Updater} update - function to receive future updates.\n *\n * @returns {import('svelte/store').Unsubscriber} Store unsubscribe function.\n */\nexport function subscribeIgnoreFirst(store, update)\n{\n   let firedFirst = false;\n\n   return store.subscribe((value) =>\n   {\n      if (!firedFirst)\n      {\n         firedFirst = true;\n      }\n      else\n      {\n         update(value);\n      }\n   });\n}\n\n/**\n * Subscribes to the given store with two update functions provided. The first function is invoked on the initial\n * subscription. All future updates are dispatched to the update function.\n *\n * @param {import('svelte/store').Readable | import('svelte/store').Writable} store -\n *  Store to subscribe to...\n *\n * @param {import('svelte/store').Updater} first - Function to receive first update.\n *\n * @param {import('svelte/store').Updater} update - Function to receive future updates.\n *\n * @returns {import('svelte/store').Unsubscriber} Store unsubscribe function.\n */\nexport function subscribeFirstRest(store, first, update)\n{\n   let firedFirst = false;\n\n   return store.subscribe((value) =>\n   {\n      if (!firedFirst)\n      {\n         firedFirst = true;\n         first(value);\n      }\n      else\n      {\n         update(value);\n      }\n   });\n}\n"],"names":[],"mappings":"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"}