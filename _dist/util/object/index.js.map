{"version":3,"file":"index.js","sources":["../../../node_modules/@typhonjs-utils/object/dist/functions.js"],"sourcesContent":["function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n\n/**\n * Provides common object manipulation utility functions and TypeScript type guards.\n *\n * @packageDocumentation\n */\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param data - An object or array.\n *\n * @param [options] - Options\n *\n * @param [options.skipKeys] - A Set of strings indicating keys of objects to not freeze.\n *\n * @returns The frozen object.\n *\n * @typeParam T - Type of data.\n */\nfunction deepFreeze(data, { skipKeys } = {}) {\n    if (typeof data !== 'object' || data === null) {\n        throw new TypeError(`deepFreeze error: 'data' is not an object or array.`);\n    }\n    if (skipKeys !== void 0 && Object.prototype.toString.call(skipKeys) !== '[object Set]') {\n        throw new TypeError(`deepFreeze error: 'options.skipKeys' is not a Set.`);\n    }\n    const stack = [data];\n    while (stack.length > 0) {\n        const obj = stack.pop();\n        if (typeof obj !== 'object' || obj === null || Object.isFrozen(obj)) {\n            continue;\n        }\n        // Collect nested properties before freezing.\n        const children = [];\n        if (Array.isArray(obj)) {\n            for (let cntr = 0; cntr < obj.length; cntr++) {\n                children.push(obj[cntr]);\n            }\n        }\n        else {\n            for (const key in obj) {\n                if (Object.hasOwn(obj, key) && !skipKeys?.has?.(key)) {\n                    children.push(obj[key]);\n                }\n            }\n        }\n        // Freeze after collecting children to avoid modifying a frozen object.\n        Object.freeze(obj);\n        // Push collected children onto the stack for further processing.\n        stack.push(...children);\n    }\n    return data;\n}\nfunction deepMerge(target, ...sourceObj) {\n    if (Object.prototype.toString.call(target) !== '[object Object]') {\n        throw new TypeError(`deepMerge error: 'target' is not an object.`);\n    }\n    if (sourceObj.length === 0) {\n        throw new TypeError(`deepMerge error: 'sourceObj' is not an object.`);\n    }\n    for (let cntr = 0; cntr < sourceObj.length; cntr++) {\n        if (Object.prototype.toString.call(sourceObj[cntr]) !== '[object Object]') {\n            throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an object.`);\n        }\n    }\n    // When merging a single source object there is an implementation that is twice as fast as multiple source objects.\n    if (sourceObj.length === 1) {\n        const stack = [];\n        for (const obj of sourceObj) {\n            stack.push({ target, source: obj });\n        }\n        while (stack.length > 0) {\n            const { target, source } = stack.pop(); // LIFO but maintains correct merge order.\n            for (const prop in source) {\n                if (Object.hasOwn(source, prop)) {\n                    const sourceValue = source[prop];\n                    const targetValue = target[prop];\n                    // If both values are plain objects, enqueue for further merging.\n                    if (Object.hasOwn(target, prop) && targetValue?.constructor === Object &&\n                        sourceValue?.constructor === Object) {\n                        stack.push({ target: targetValue, source: sourceValue });\n                    }\n                    else {\n                        target[prop] = sourceValue;\n                    }\n                }\n            }\n        }\n    }\n    else // Stack implementation for multiple source objects.\n     {\n        const stack = [{ target, sources: sourceObj }];\n        while (stack.length > 0) {\n            const { target, sources } = stack.pop();\n            for (const source of sources) {\n                for (const prop in source) {\n                    if (Object.hasOwn(source, prop)) {\n                        const sourceValue = source[prop];\n                        const targetValue = target[prop];\n                        // If both values are plain objects, push for further merging with a new object.\n                        if (Object.hasOwn(target, prop) && targetValue?.constructor === Object &&\n                            sourceValue?.constructor === Object) {\n                            target[prop] = Object.assign({}, targetValue); // Copy existing target data.\n                            stack.push({ target: target[prop], sources: [sourceValue] });\n                        }\n                        else {\n                            target[prop] = sourceValue;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return target;\n}\n/**\n * Seals all entries traversed that are objects including entries in arrays.\n *\n * @param data - An object or array.\n *\n * @param [options] - Options\n *\n * @param [options.skipKeys] - A Set of strings indicating keys of objects to not seal.\n *\n * @returns The sealed object.\n *\n * @typeParam T - Type of data.\n */\nfunction deepSeal(data, { skipKeys } = {}) {\n    if (typeof data !== 'object' || data === null) {\n        throw new TypeError(`deepSeal error: 'data' is not an object or array.`);\n    }\n    if (skipKeys !== void 0 && Object.prototype.toString.call(skipKeys) !== '[object Set]') {\n        throw new TypeError(`deepSeal error: 'options.skipKeys' is not a Set.`);\n    }\n    const stack = [data];\n    while (stack.length > 0) {\n        const obj = stack.pop();\n        if (typeof obj !== 'object' || obj === null || Object.isSealed(obj)) {\n            continue;\n        }\n        // Collect nested properties before freezing.\n        const children = [];\n        if (Array.isArray(obj)) {\n            for (let cntr = 0; cntr < obj.length; cntr++) {\n                children.push(obj[cntr]);\n            }\n        }\n        else {\n            for (const key in obj) {\n                if (Object.hasOwn(obj, key) && !skipKeys?.has?.(key)) {\n                    children.push(obj[key]);\n                }\n            }\n        }\n        // Freeze after collecting children to avoid modifying a frozen object.\n        Object.seal(obj);\n        // Push collected children onto the stack for further processing.\n        stack.push(...children);\n    }\n    return data;\n}\n/**\n * Determine if the given object has a getter & setter accessor.\n *\n * @param object - An object.\n *\n * @param accessor - Accessor to test.\n *\n * @returns Whether the given object has the getter and setter for accessor.\n *\n * @typeParam T - Type of data.\n * @typeParam K - Accessor key.\n */\nfunction hasAccessor(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.get !== void 0 && iDescriptor.set !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.get !== void 0 && descriptor.set !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determine if the given object has a getter accessor.\n *\n * @param object - An object.\n *\n * @param accessor - Accessor to test.\n *\n * @returns Whether the given object has the getter for accessor.\n *\n * @typeParam T - Type of data.\n * @typeParam K - Accessor key.\n */\nfunction hasGetter(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.get !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Returns whether the target is or has the given prototype walking up the prototype chain.\n *\n * @param target - Any target class / constructor function to test.\n *\n * @param Prototype - Class / constructor function to find.\n *\n * @returns Target matches prototype.\n *\n * @typeParam T - Prototype class / constructor.\n */\nfunction hasPrototype(target, Prototype) {\n    if (typeof target !== 'function') {\n        return false;\n    }\n    if (target === Prototype) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {\n        if (proto === Prototype) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determine if the given object has a setter accessor.\n *\n * @param object - An object.\n *\n * @param accessor - Accessor to test.\n *\n * @returns Whether the given object has the setter for accessor.\n *\n * @typeParam T - Type of data.\n * @typeParam K - Accessor key.\n */\nfunction hasSetter(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.set !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.set !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Tests for whether an object is async iterable.\n *\n * @param value - Any value.\n *\n * @returns Whether value is async iterable.\n */\nfunction isAsyncIterable(value) {\n    if (typeof value !== 'object' || value === null || value === void 0) {\n        return false;\n    }\n    return Symbol.asyncIterator in value;\n}\n/**\n * Tests for whether an object is iterable.\n *\n * @param value - Any value.\n *\n * @returns Whether object is iterable.\n */\nfunction isIterable(value) {\n    if (value === null || value === void 0 || typeof value !== 'object') {\n        return false;\n    }\n    return Symbol.iterator in value;\n}\n/**\n * Tests for whether object is not null, typeof object, and not an array.\n *\n * @param value - Any value.\n *\n * @returns Is it an object.\n */\nfunction isObject(value) {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n/**\n * Tests for whether the given value is a plain object.\n *\n * An object is plain if it is created by either: `{}`, `new Object()` or `Object.create(null)`.\n *\n * @param value - Any value\n *\n * @returns Is it a plain object.\n */\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param object - An object.\n *\n * @returns Object keys or empty array.\n */\nfunction objectKeys(object) {\n    return typeof object === 'object' && object !== null ? Object.keys(object) : [];\n}\n/**\n * Safely returns an objects size. Note for String objects Unicode is not taken into consideration.\n *\n * @param object - Any value, but size returned for object / Map / Set / arrays / strings.\n *\n * @returns Size of object.\n */\nfunction objectSize(object) {\n    if (object === void 0 || object === null || typeof object !== 'object') {\n        return 0;\n    }\n    const tag = Object.prototype.toString.call(object);\n    if (tag === '[object Map]' || tag === '[object Set]') {\n        return object.size;\n    }\n    if (tag === '[object String]') {\n        return object.length;\n    }\n    return Object.keys(object).length;\n}\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param data - An object to access entry data.\n *\n * @param accessor - A string describing the entries to access with keys separated by `.`.\n *\n * @param [defaultValue] - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns The value referenced by the accessor.\n *\n * @typeParam T - Type of data.\n * @typeParam P - Accessor type.\n * @typeParam R - Return value / Inferred deep access type or any provided default value type.\n */\nfunction safeAccess(data, accessor, defaultValue) {\n    if (typeof data !== 'object' || data === null) {\n        return defaultValue;\n    }\n    if (typeof accessor !== 'string') {\n        return defaultValue;\n    }\n    const keys = accessor.split('.');\n    let result = data;\n    // Walk through the given object by the accessor indexes.\n    for (let cntr = 0; cntr < keys.length; cntr++) {\n        // If the next level of object access is undefined or null then return the default value.\n        if (result[keys[cntr]] === void 0 || result[keys[cntr]] === null) {\n            return defaultValue;\n        }\n        result = result[keys[cntr]];\n    }\n    return result;\n}\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * Note: The source and target should be JSON objects.\n *\n * @param source - Source object.\n *\n * @param target - Target object.\n *\n * @param [options] - Options.\n *\n * @param [options.arrayIndex] - Set to `false` to exclude equality testing for array contents; default: `true`.\n *\n * @param [options.hasOwnOnly] - Set to `false` to include enumerable prototype properties; default: `true`.\n *\n * @returns True if equal.\n */\nfunction safeEqual(source, target, options) {\n    if (typeof source !== 'object' || source === null || typeof target !== 'object' || target === null) {\n        return false;\n    }\n    for (const accessor of safeKeyIterator(source, options)) {\n        const sourceObjectValue = safeAccess(source, accessor);\n        const targetObjectValue = safeAccess(target, accessor);\n        if (sourceObjectValue !== targetObjectValue) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns an iterator of safe keys useful with {@link safeAccess} and {@link safeSet} by traversing the given object.\n *\n * Note: Keys are only generated for JSON objects; {@link Map} and {@link Set} are not indexed.\n *\n * @param data - An object to traverse for accessor keys.\n *\n * @param [options] - Options.\n *\n * @param [options.arrayIndex] - Set to `false` to exclude safe keys for array indexing; default: `true`.\n *\n * @param [options.hasOwnOnly] - Set to `false` to include enumerable prototype properties; default: `true`.\n *\n * @returns Safe key iterator.\n */\nfunction* safeKeyIterator(data, { arrayIndex = true, hasOwnOnly = true } = {}) {\n    if (typeof data !== 'object' || data === null) {\n        throw new TypeError(`safeKeyIterator error: 'data' is not an object.`);\n    }\n    if (typeof arrayIndex !== 'boolean') {\n        throw new TypeError(`safeKeyIterator error: 'options.arrayIndex' is not a boolean.`);\n    }\n    if (typeof hasOwnOnly !== 'boolean') {\n        throw new TypeError(`safeKeyIterator error: 'options.hasOwnOnly' is not a boolean.`);\n    }\n    const stack = [{ obj: data, prefix: '' }];\n    while (stack.length > 0) {\n        const { obj, prefix } = stack.pop();\n        for (const key in obj) {\n            if (hasOwnOnly && !Object.hasOwn(obj, key)) {\n                continue;\n            }\n            const fullKey = prefix ? `${prefix}.${key}` : key;\n            const value = obj[key];\n            if (Array.isArray(value)) {\n                if (!arrayIndex) {\n                    continue;\n                }\n                for (let cntr = 0; cntr < value.length; cntr++) {\n                    yield `${fullKey}.${cntr}`;\n                }\n            }\n            else if (typeof value === 'object' && value !== null) {\n                stack.push({ obj: value, prefix: fullKey }); // Push to stack for DFS traversal.\n            }\n            else if (typeof value !== 'function') {\n                yield fullKey;\n            }\n        }\n    }\n}\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param data - An object to access entry data.\n *\n * @param accessor - A string describing the entries to access.\n *\n * @param value - A new value to set if an entry for accessor is found.\n *\n * @param [options] - Options.\n *\n * @param [options.operation] - Operation to perform including: `add`, `div`, `mult`, `set`, `set-undefined`, `sub`;\n *        default: `set`.\n *\n * @param [options.createMissing] - If `true` missing accessor entries will be created as objects automatically;\n *        default: `false`.\n *\n * @returns True if successful.\n */\nfunction safeSet(data, accessor, value, { operation = 'set', createMissing = false } = {}) {\n    if (typeof data !== 'object' || data === null) {\n        throw new TypeError(`safeSet error: 'data' is not an object.`);\n    }\n    if (typeof accessor !== 'string') {\n        throw new TypeError(`safeSet error: 'accessor' is not a string.`);\n    }\n    if (typeof operation !== 'string') {\n        throw new TypeError(`safeSet error: 'options.operation' is not a string.`);\n    }\n    if (operation !== 'add' && operation !== 'div' && operation !== 'mult' && operation !== 'set' &&\n        operation !== 'set-undefined' && operation !== 'sub') {\n        throw new Error(`safeSet error: Unknown 'options.operation'.`);\n    }\n    if (typeof createMissing !== 'boolean') {\n        throw new TypeError(`safeSet error: 'options.createMissing' is not a boolean.`);\n    }\n    const access = accessor.split('.');\n    let result = false;\n    // Verify first level missing property.\n    if (access.length === 1 && !createMissing && !(access[0] in data)) {\n        return false;\n    }\n    // Walk through the given object by the accessor indexes.\n    for (let cntr = 0; cntr < access.length; cntr++) {\n        // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n        if (Array.isArray(data)) {\n            const number = (+access[cntr]);\n            if (!Number.isInteger(number) || number < 0) {\n                return false;\n            }\n        }\n        if (cntr === access.length - 1) {\n            switch (operation) {\n                case 'add':\n                    data[access[cntr]] += value;\n                    result = true;\n                    break;\n                case 'div':\n                    data[access[cntr]] /= value;\n                    result = true;\n                    break;\n                case 'mult':\n                    data[access[cntr]] *= value;\n                    result = true;\n                    break;\n                case 'set':\n                    data[access[cntr]] = value;\n                    result = true;\n                    break;\n                case 'set-undefined':\n                    if (data[access[cntr]] === void 0) {\n                        data[access[cntr]] = value;\n                    }\n                    result = true;\n                    break;\n                case 'sub':\n                    data[access[cntr]] -= value;\n                    result = true;\n                    break;\n            }\n        }\n        else {\n            // If createMissing is true and the next level of object access is undefined then create a new object entry.\n            if (createMissing && data[access[cntr]] === void 0) {\n                data[access[cntr]] = {};\n            }\n            // Abort if the next level is null or not an object and containing a value.\n            if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') {\n                return false;\n            }\n            data = data[access[cntr]];\n        }\n    }\n    return result;\n}\n\nexport { deepFreeze, deepMerge, deepSeal, hasAccessor, hasGetter, hasPrototype, hasSetter, isAsyncIterable, isIterable, isObject, isPlainObject, klona, objectKeys, objectSize, safeAccess, safeEqual, safeKeyIterator, safeSet };\n//# sourceMappingURL=functions.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}