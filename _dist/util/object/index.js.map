{"version":3,"file":"index.js","sources":["../../../node_modules/@typhonjs-utils/object/dist/functions.js"],"sourcesContent":["function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nfunction klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n\n/**\n * Provides common object manipulation utilities including depth traversal, obtaining accessors, safely setting values /\n * equality tests, and validation.\n */\nconst s_TAG_OBJECT = '[object Object]';\nconst s_TAG_MAP = '[object Map]';\nconst s_TAG_SET = '[object Set]';\nconst s_TAG_STRING = '[object String]';\n/**\n * Freezes all entries traversed that are objects including entries in arrays.\n *\n * @param {object | []}   data - An object or array.\n *\n * @param {Set<string>}   [skipFreezeKeys] - A Set of strings indicating keys of objects to not freeze.\n *\n * @returns {object | []} The frozen object.\n */\nfunction deepFreeze(data, skipFreezeKeys) {\n    /* c8 ignore next 1 */\n    if (typeof data !== 'object') {\n        throw new TypeError(`'data' is not an 'object'.`);\n    }\n    /* c8 ignore next 4 */\n    if (skipFreezeKeys !== void 0 && !(skipFreezeKeys instanceof Set)) {\n        throw new TypeError(`'skipFreezeKeys' is not an 'Set'.`);\n    }\n    return _deepFreeze(data, skipFreezeKeys);\n}\n/**\n * Recursively deep merges all source objects into the target object in place. Like `Object.assign` if you provide `{}`\n * as the target a copy is produced. If the target and source property are object literals they are merged.\n * Deleting keys is supported by specifying a property starting with `-=`.\n *\n * @param {object}      target - Target object.\n *\n * @param {...object}   sourceObj - One or more source objects.\n *\n * @returns {object}    Target object.\n */\nfunction deepMerge(target = {}, ...sourceObj) {\n    if (Object.prototype.toString.call(target) !== s_TAG_OBJECT) {\n        throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);\n    }\n    for (let cntr = 0; cntr < sourceObj.length; cntr++) {\n        if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT) {\n            throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);\n        }\n    }\n    return _deepMerge(target, ...sourceObj);\n}\n/**\n * Performs a naive depth traversal of an object / array. The data structure _must not_ have circular references.\n * The result of the callback function is used to modify in place the given data.\n *\n * @param {object | []}   data - An object or array.\n *\n * @param {(any) => any}  func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}       modify - If true then the result of the callback function is used to modify in place\n *                                  the given data.\n *\n * @returns {*} The data object.\n */\nfunction depthTraverse(data, func, modify = false) {\n    /* c8 ignore next 1 */\n    if (typeof data !== 'object') {\n        throw new TypeError(`'data' is not an 'object'.`);\n    }\n    /* c8 ignore next 1 */\n    if (typeof func !== 'function') {\n        throw new TypeError(`'func' is not a 'function'.`);\n    }\n    return _depthTraverse(data, func, modify);\n}\n/**\n * Returns a list of accessor keys by traversing the given object.\n *\n * @param {object}   data - An object to traverse for accessor keys.\n *\n * @returns {string[]} Accessor list.\n */\nfunction getAccessorList(data) {\n    if (typeof data !== 'object') {\n        throw new TypeError(`getAccessorList error: 'data' is not an 'object'.`);\n    }\n    return _getAccessorList(data);\n}\n/**\n * Provides a method to determine if the passed in Svelte component has a getter & setter accessor.\n *\n * @param {object}   object - An object.\n *\n * @param {string}   accessor - Accessor to test.\n *\n * @returns {boolean} Whether the component has the getter and setter for accessor.\n */\nfunction hasAccessor(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.get !== void 0 && iDescriptor.set !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.get !== void 0 && descriptor.set !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Provides a method to determine if the passed in Svelte component has a getter accessor.\n *\n * @param {object}   object - An object.\n *\n * @param {string}   accessor - Accessor to test.\n *\n * @returns {boolean} Whether the component has the getter for accessor.\n */\nfunction hasGetter(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.get !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Returns whether the target is or has the given prototype walking up the prototype chain.\n *\n * @param {unknown}  target - Any target to test.\n *\n * @param {new (...args: any[]) => any} Prototype - Prototype function / class constructor to find.\n *\n * @returns {boolean} Target matches prototype.\n */\nfunction hasPrototype(target, Prototype) {\n    /* c8 ignore next */\n    if (typeof target !== 'function') {\n        return false;\n    }\n    if (target === Prototype) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let proto = Object.getPrototypeOf(target); proto; proto = Object.getPrototypeOf(proto)) {\n        if (proto === Prototype) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Provides a method to determine if the passed in Svelte component has a setter accessor.\n *\n * @param {object}   object - An object.\n *\n * @param {string}   accessor - Accessor to test.\n *\n * @returns {boolean} Whether the component has the setter for accessor.\n */\nfunction hasSetter(object, accessor) {\n    if (typeof object !== 'object' || object === null || object === void 0) {\n        return false;\n    }\n    // Check for instance accessor.\n    const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);\n    if (iDescriptor !== void 0 && iDescriptor.set !== void 0) {\n        return true;\n    }\n    // Walk parent prototype chain. Check for descriptor at each prototype level.\n    for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {\n        const descriptor = Object.getOwnPropertyDescriptor(o, accessor);\n        if (descriptor !== void 0 && descriptor.set !== void 0) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Tests for whether an object is async iterable.\n *\n * @param {unknown} value - Any value.\n *\n * @returns {boolean} Whether value is async iterable.\n */\nfunction isAsyncIterable(value) {\n    if (typeof value !== 'object' || value === null || value === void 0) {\n        return false;\n    }\n    return Symbol.asyncIterator in value;\n}\n/**\n * Tests for whether an object is iterable.\n *\n * @param {unknown} value - Any value.\n *\n * @returns {boolean} Whether object is iterable.\n */\nfunction isIterable(value) {\n    if (value === null || value === void 0 || typeof value !== 'object') {\n        return false;\n    }\n    return Symbol.iterator in value;\n}\n/**\n * Tests for whether object is not null, typeof object, and not an array.\n *\n * @param {unknown} value - Any value.\n *\n * @returns {boolean} Is it an object.\n */\nfunction isObject(value) {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n/**\n * Tests for whether the given value is a plain object.\n *\n * An object is plain if it is created by either: `{}`, `new Object()` or `Object.create(null)`.\n *\n * @param {unknown} value - Any value\n *\n * @returns {boolean} Is it a plain object.\n */\nfunction isPlainObject(value) {\n    if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Safely returns keys on an object or an empty array if not an object.\n *\n * @param {object} object - An object.\n *\n * @returns {string[]}  Object keys or empty array.\n */\nfunction objectKeys(object) {\n    return isObject(object) ? Object.keys(object) : [];\n}\n/**\n * Safely returns an objects size. Note for String objects unicode is not taken into consideration.\n *\n * @param {any} object - Any value, but size returned for object / Map / Set / arrays / strings.\n *\n * @returns {number} Size of object.\n */\nfunction objectSize(object) {\n    if (object === void 0 || object === null || typeof object !== 'object') {\n        return 0;\n    }\n    const tag = Object.prototype.toString.call(object);\n    if (tag === s_TAG_MAP || tag === s_TAG_SET) {\n        return object.size;\n    }\n    if (tag === s_TAG_STRING) {\n        return object.length;\n    }\n    return Object.keys(object).length;\n}\n/**\n * Provides a way to safely access an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access with keys separated by `.`.\n *\n * @param {any}      [defaultValue] - (Optional) A default value to return if an entry for accessor is not found.\n *\n * @returns {object} The data object.\n */\nfunction safeAccess(data, accessor, defaultValue) {\n    if (typeof data !== 'object') {\n        return defaultValue;\n    }\n    if (typeof accessor !== 'string') {\n        return defaultValue;\n    }\n    const access = accessor.split('.');\n    // Walk through the given object by the accessor indexes.\n    for (let cntr = 0; cntr < access.length; cntr++) {\n        // If the next level of object access is undefined or null then return the empty string.\n        if (typeof data[access[cntr]] === 'undefined' || data[access[cntr]] === null) {\n            return defaultValue;\n        }\n        data = data[access[cntr]];\n    }\n    return data;\n}\n/**\n * Provides a way to safely batch set an objects data / entries given an array of accessor strings which describe the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk. If value is an object the accessor will be used to access a target value from `value` which is\n * subsequently set to `data` by the given operation. If `value` is not an object it will be used as the target\n * value to set across all accessors.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string[]} accessors - A string describing the entries to access.\n *\n * @param {any}      value - A new value to set if an entry for accessor is found.\n *\n * @param {SafeSetOperation}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *        'set-undefined', 'sub'.\n *\n * @param {any}      [defaultAccessValue=0] - A new value to set if an entry for accessor is found.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects automatically.\n */\nfunction safeBatchSet(data, accessors, value, operation = 'set', defaultAccessValue = 0, createMissing = true) {\n    if (typeof data !== 'object') {\n        throw new TypeError(`safeBatchSet error: 'data' is not an 'object'.`);\n    }\n    if (!Array.isArray(accessors)) {\n        throw new TypeError(`safeBatchSet error: 'accessors' is not an 'array'.`);\n    }\n    if (typeof value === 'object') {\n        accessors.forEach((accessor) => {\n            const targetValue = safeAccess(value, accessor, defaultAccessValue);\n            safeSet(data, accessor, targetValue, operation, createMissing);\n        });\n    }\n    else {\n        accessors.forEach((accessor) => {\n            safeSet(data, accessor, value, operation, createMissing);\n        });\n    }\n}\n/**\n * Compares a source object and values of entries against a target object. If the entries in the source object match\n * the target object then `true` is returned otherwise `false`. If either object is undefined or null then false\n * is returned.\n *\n * @param {object}   source - Source object.\n *\n * @param {object}   target - Target object.\n *\n * @returns {boolean} True if equal.\n */\nfunction safeEqual(source, target) {\n    if (typeof source === 'undefined' || source === null || typeof target === 'undefined' || target === null) {\n        return false;\n    }\n    const sourceAccessors = getAccessorList(source);\n    for (let cntr = 0; cntr < sourceAccessors.length; cntr++) {\n        const accessor = sourceAccessors[cntr];\n        const sourceObjectValue = safeAccess(source, accessor);\n        const targetObjectValue = safeAccess(target, accessor);\n        if (sourceObjectValue !== targetObjectValue) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Provides a way to safely set an objects data / entries given an accessor string which describes the\n * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries\n * to walk.\n *\n * @param {object}   data - An object to access entry data.\n *\n * @param {string}   accessor - A string describing the entries to access.\n *\n * @param {any}      value - A new value to set if an entry for accessor is found.\n *\n * @param {SafeSetOperation}   [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set',\n *        'set-undefined', 'sub'.\n *\n * @param {boolean}  [createMissing=true] - If true missing accessor entries will be created as objects\n *        automatically.\n *\n * @returns {boolean} True if successful.\n */\nfunction safeSet(data, accessor, value, operation = 'set', createMissing = true) {\n    if (typeof data !== 'object') {\n        throw new TypeError(`safeSet error: 'data' is not an 'object'.`);\n    }\n    if (typeof accessor !== 'string') {\n        throw new TypeError(`safeSet error: 'accessor' is not a 'string'.`);\n    }\n    const access = accessor.split('.');\n    // Walk through the given object by the accessor indexes.\n    for (let cntr = 0; cntr < access.length; cntr++) {\n        // If data is an array perform validation that the accessor is a positive integer otherwise quit.\n        if (Array.isArray(data)) {\n            const number = (+access[cntr]);\n            if (!Number.isInteger(number) || number < 0) {\n                return false;\n            }\n        }\n        if (cntr === access.length - 1) {\n            switch (operation) {\n                case 'add':\n                    data[access[cntr]] += value;\n                    break;\n                case 'div':\n                    data[access[cntr]] /= value;\n                    break;\n                case 'mult':\n                    data[access[cntr]] *= value;\n                    break;\n                case 'set':\n                    data[access[cntr]] = value;\n                    break;\n                case 'set-undefined':\n                    if (typeof data[access[cntr]] === 'undefined') {\n                        data[access[cntr]] = value;\n                    }\n                    break;\n                case 'sub':\n                    data[access[cntr]] -= value;\n                    break;\n            }\n        }\n        else {\n            // If createMissing is true and the next level of object access is undefined then create a new object entry.\n            if (createMissing && typeof data[access[cntr]] === 'undefined') {\n                data[access[cntr]] = {};\n            }\n            // Abort if the next level is null or not an object and containing a value.\n            if (data[access[cntr]] === null || typeof data[access[cntr]] !== 'object') {\n                return false;\n            }\n            data = data[access[cntr]];\n        }\n    }\n    return true;\n}\n/**\n * Performs bulk setting of values to the given data object.\n *\n * @param {object}            data - The data object to set data.\n *\n * @param {Record<string, any>}  accessorValues - Object of accessor keys to values to set.\n *\n * @param {SafeSetOperation}  [operation='set'] - Operation to perform including: 'add', 'div', 'mult', 'set', 'sub';\n *        default (`set`).\n *\n * @param {boolean}           [createMissing=true] - If true missing accessor entries will be created as objects\n *        automatically.\n */\nfunction safeSetAll(data, accessorValues, operation = 'set', createMissing = true) {\n    if (typeof data !== 'object') {\n        throw new TypeError(`safeSetAll error: 'data' is not an 'object'.`);\n    }\n    if (typeof accessorValues !== 'object') {\n        throw new TypeError(`safeSetAll error: 'accessorValues' is not an 'object'.`);\n    }\n    for (const accessor of Object.keys(accessorValues)) {\n        if (!Object.prototype.hasOwnProperty.call(accessorValues, accessor)) {\n            continue;\n        }\n        safeSet(data, accessor, accessorValues[accessor], operation, createMissing);\n    }\n}\n/**\n * Performs bulk validation of data given an object, `validationData`, which describes all entries to test.\n *\n * @param {object}                           data - The data object to test.\n *\n * @param {Record<string, ValidationEntry>}  validationData - Key is the accessor / value is a validation entry.\n *\n * @param {string}                           [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nfunction validate(data, validationData = {}, dataName = 'data') {\n    if (typeof data !== 'object') {\n        throw new TypeError(`validate error: '${dataName}' is not an 'object'.`);\n    }\n    if (typeof validationData !== 'object') {\n        throw new TypeError(`validate error: 'validationData' is not an 'object'.`);\n    }\n    let result;\n    for (const key of Object.keys(validationData)) {\n        if (!Object.prototype.hasOwnProperty.call(validationData, key)) {\n            continue;\n        }\n        const entry = validationData[key];\n        switch (entry.test) {\n            case 'array':\n                result = validateArray(data, key, entry, dataName);\n                break;\n            case 'entry':\n                result = validateEntry(data, key, entry, dataName);\n                break;\n            case 'entry|array':\n                result = validateEntryOrArray(data, key, entry, dataName);\n                break;\n        }\n    }\n    return result;\n}\n/**\n * Validates all array entries against potential type and expected tests.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   entry - Validation entry object\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nfunction validateArray(data, accessor, entry, dataName = 'data') {\n    const valEntry = Object.assign({ required: true, error: true }, entry);\n    const dataArray = safeAccess(data, accessor);\n    // A non-required entry is missing so return without validation.\n    if (!valEntry?.required && typeof dataArray === 'undefined') {\n        return true;\n    }\n    if (!Array.isArray(dataArray)) {\n        if (valEntry.error) {\n            throw _validateError(TypeError, `'${dataName}.${accessor}' is not an 'array'.`);\n        }\n        else {\n            return false;\n        }\n    }\n    if (typeof valEntry.type === 'string') {\n        for (let cntr = 0; cntr < dataArray.length; cntr++) {\n            if (!(typeof dataArray[cntr] === valEntry.type)) {\n                if (valEntry.error) {\n                    const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                        dataArray[cntr];\n                    throw _validateError(TypeError, `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not a '${valEntry.type}'.`);\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n    }\n    // If expected is a function then test all array entries against the test function. If expected is a Set then\n    // test all array entries for inclusion in the set. Otherwise, if expected is a string then test that all array\n    // entries as a `typeof` test against expected.\n    if (Array.isArray(valEntry.expected)) {\n        for (let cntr = 0; cntr < dataArray.length; cntr++) {\n            if (!valEntry.expected.includes(dataArray[cntr])) {\n                if (valEntry.error) {\n                    const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                        dataArray[cntr];\n                    throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not an expected value: ${JSON.stringify(valEntry.expected)}.`);\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n    }\n    else if (valEntry.expected instanceof Set) {\n        for (let cntr = 0; cntr < dataArray.length; cntr++) {\n            if (!valEntry.expected.has(dataArray[cntr])) {\n                if (valEntry.error) {\n                    const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                        dataArray[cntr];\n                    throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' is not an expected value: ${JSON.stringify(valEntry.expected)}.`);\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n    }\n    else if (typeof valEntry.expected === 'function') {\n        for (let cntr = 0; cntr < dataArray.length; cntr++) {\n            try {\n                const result = valEntry.expected(dataArray[cntr]);\n                if (typeof result === 'undefined' || !result) {\n                    throw new Error(valEntry.message);\n                }\n            }\n            catch (err) {\n                if (valEntry.error) {\n                    const dataEntryString = typeof dataArray[cntr] === 'object' ? JSON.stringify(dataArray[cntr]) :\n                        dataArray[cntr];\n                    throw _validateError(Error, `'${dataName}.${accessor}[${cntr}]': '${dataEntryString}' failed validation: ${err.message}.`);\n                }\n                else {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n/**\n * Validates data entry with a typeof check and potentially tests against the values in any given expected set.\n *\n * @param {object}            data - The object data to validate.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   entry - Validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nfunction validateEntry(data, accessor, entry, dataName = 'data') {\n    const valEntry = Object.assign({ required: true, error: true }, entry);\n    const dataEntry = safeAccess(data, accessor);\n    // A non-required entry is missing so return without validation.\n    if (!valEntry.required && typeof dataEntry === 'undefined') {\n        return true;\n    }\n    if (valEntry.type && typeof dataEntry !== valEntry.type) {\n        if (valEntry.error) {\n            throw _validateError(TypeError, `'${dataName}.${accessor}' is not a '${valEntry.type}'.`);\n        }\n        else {\n            return false;\n        }\n    }\n    if ((valEntry.expected instanceof Set && !valEntry.expected.has(dataEntry)) ||\n        (Array.isArray(valEntry.expected) && !valEntry.expected.includes(dataEntry))) {\n        if (valEntry.error) {\n            const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n            throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' is not an expected value: ${JSON.stringify(valEntry.expected)}.`);\n        }\n        else {\n            return false;\n        }\n    }\n    else if (typeof valEntry.expected === 'function') {\n        try {\n            const result = valEntry.expected(dataEntry);\n            if (typeof result === 'undefined' || !result) {\n                throw new Error(valEntry.message);\n            }\n        }\n        catch (err) {\n            if (valEntry.error) {\n                const dataEntryString = typeof dataEntry === 'object' ? JSON.stringify(dataEntry) : dataEntry;\n                throw _validateError(Error, `'${dataName}.${accessor}': '${dataEntryString}' failed to validate: ${err.message}.`);\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n/**\n * Dispatches validation of data entry to string or array validation depending on data entry type.\n *\n * @param {object}            data - The data object to test.\n *\n * @param {string}            accessor - A string describing the entries to access.\n *\n * @param {ValidationEntry}   [entry] - A validation entry.\n *\n * @param {string}            [dataName='data'] - Optional name of data.\n *\n * @returns {boolean} True if validation passes otherwise an exception is thrown.\n */\nfunction validateEntryOrArray(data, accessor, entry, dataName = 'data') {\n    const dataEntry = safeAccess(data, accessor);\n    let result;\n    if (Array.isArray(dataEntry)) {\n        result = validateArray(data, accessor, entry, dataName);\n    }\n    else {\n        result = validateEntry(data, accessor, entry, dataName);\n    }\n    return result;\n}\n// Module private ---------------------------------------------------------------------------------------------------\n/**\n * Private implementation of depth traversal.\n *\n * @param {any}         data - An object or array or any leaf.\n *\n * @param {Set<string>} [skipFreezeKeys] - An array of strings indicating keys of objects to not freeze.\n *\n * @returns {*} The frozen object.\n * @ignore\n * @private\n */\nfunction _deepFreeze(data, skipFreezeKeys) {\n    if (Array.isArray(data)) {\n        for (let cntr = 0; cntr < data.length; cntr++) {\n            _deepFreeze(data[cntr], skipFreezeKeys);\n        }\n    }\n    else if (isObject(data)) {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key) && !skipFreezeKeys?.has?.(key)) {\n                _deepFreeze(data[key], skipFreezeKeys);\n            }\n        }\n    }\n    return Object.freeze(data);\n}\n/**\n * Internal implementation for `deepMerge`.\n *\n * @param {object}      target - Target object.\n *\n * @param {...object}   sourceObj - One or more source objects.\n *\n * @returns {object}    Target object.\n */\nfunction _deepMerge(target = {}, ...sourceObj) {\n    // Iterate and merge all source objects into target.\n    for (let cntr = 0; cntr < sourceObj.length; cntr++) {\n        const obj = sourceObj[cntr];\n        for (const prop in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n                // Handle the special property starting with '-=' to delete keys.\n                if (prop.startsWith('-=')) {\n                    delete target[prop.slice(2)];\n                    continue;\n                }\n                // If target already has prop and both target[prop] and obj[prop] are object literals then merge them\n                // otherwise assign obj[prop] to target[prop].\n                target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object &&\n                    obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];\n            }\n        }\n    }\n    return target;\n}\n/**\n * Private implementation of depth traversal.\n *\n * @param {any}      data - An object, array, or any leaf value\n *\n * @param {Function} func - A callback function to process leaf values in children arrays or object members.\n *\n * @param {boolean}  modify - If true then the result of the callback function is used to modify in place the\n *        given data.\n *\n * @returns {*} The data object.\n * @ignore\n * @private\n */\nfunction _depthTraverse(data, func, modify = false) {\n    if (modify) {\n        if (Array.isArray(data)) {\n            for (let cntr = 0; cntr < data.length; cntr++) {\n                data[cntr] = _depthTraverse(data[cntr], func, modify);\n            }\n        }\n        else if (isObject(data)) {\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    data[key] = _depthTraverse(data[key], func, modify);\n                }\n            }\n        }\n        else {\n            data = func(data);\n        }\n    }\n    else {\n        if (Array.isArray(data)) {\n            for (let cntr = 0; cntr < data.length; cntr++) {\n                _depthTraverse(data[cntr], func, modify);\n            }\n        }\n        else if (typeof data === 'object') {\n            for (const key in data) {\n                if (Object.prototype.hasOwnProperty.call(data, key)) {\n                    _depthTraverse(data[key], func, modify);\n                }\n            }\n        }\n        else {\n            func(data);\n        }\n    }\n    return data;\n}\n/**\n * Private implementation of `getAccessorList`.\n *\n * @param {object}   data - An object to traverse.\n *\n * @returns {string[]} Accessor list.\n * @ignore\n * @private\n */\nfunction _getAccessorList(data) {\n    const accessors = [];\n    for (const key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n            if (typeof data[key] === 'object') {\n                const childKeys = _getAccessorList(data[key]);\n                childKeys.forEach((childKey) => {\n                    accessors.push(Array.isArray(childKey) ? `${key}.${childKey.join('.')}` : `${key}.${childKey}`);\n                });\n            }\n            else {\n                accessors.push(key);\n            }\n        }\n    }\n    return accessors;\n}\n/**\n * Creates a new error of type `clazz` adding the field `_objectValidateError` set to true.\n *\n * @param {Error}    clazz - Error class to instantiate.\n *\n * @param {string}   message - An error message.\n *\n * @returns {*} Error of the clazz.\n * @ignore\n * @private\n */\nfunction _validateError(clazz, message = void 0) {\n    const error = new clazz(message);\n    error._objectValidateError = true;\n    return error;\n}\n\nexport { deepFreeze, deepMerge, depthTraverse, getAccessorList, hasAccessor, hasGetter, hasPrototype, hasSetter, isAsyncIterable, isIterable, isObject, isPlainObject, klona, objectKeys, objectSize, safeAccess, safeBatchSet, safeEqual, safeSet, safeSetAll, validate, validateArray, validateEntry, validateEntryOrArray };\n//# sourceMappingURL=functions.js.map\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}