{"version":3,"file":"index.js","sources":["../../../src/svelte/animate/animateEvents.js"],"sourcesContent":["import { isWritableStore } from '#runtime/util/store';\n\n/**\n * Svelte doesn't provide any events for the animate directive.\n *\n * The provided function below wraps a Svelte animate directive function generating bubbling events for start & end of\n * animation.\n *\n * These events are `animate:start` and `animate:end`.\n *\n * This is useful for instance if you are animating several nodes in a scrollable container where the overflow parameter\n * needs to be set to `none` while animating such that the scrollbar is not activated by the animation.\n *\n * Optionally you may also provide a boolean writable store that will be set to true when animation is active. In some\n * cases this leads to an easier implementation for gating on animation state.\n *\n * @example <caption>With events</caption>\n * const flipWithEvents = animateEvents(flip);\n * </script>\n *\n * <main on:animate:start={() => console.log('animate:start')\n *       on:animate:end={() => console.log('animate:end')}>\n *    {#each someData as entry (entry.id)}\n *       <section animate:flipWithEvents />\n *    {/each}\n\n * @example <caption>With optional store</caption>\n * const isAnimating = writable(false);\n * const flipWithEvents = animateEvents(flip, isAnimating);\n * </script>\n *\n * <main class:no-scroll={$isAnimating}>\n *    {#each someData as entry (entry.id)}\n *       <section animate:flipWithEvents />\n *    {/each}\n *\n * @param {(\n *    node: Element,\n *    data: { from: DOMRect, to: DOMRect },\n *    ...rest: any\n * ) => import('svelte/animate').AnimationConfig} fn - A Svelte animation function.\n *\n * @param {import('svelte/store').Writable<boolean>} [store] - An optional boolean writable store that is set to true\n *        when animation is active.\n *\n * @returns {(\n *    node: Element,\n *    data: { from: DOMRect, to: DOMRect },\n *    ...rest: any\n * ) => import('svelte/animate').AnimationConfig} Wrapped animation function.\n */\nexport function animateEvents(fn, store = void 0)\n{\n   if (typeof fn !== 'function') { throw new TypeError(`'fn' is not a function.`); }\n   if (store !== void 0 && !isWritableStore(store)) { throw new TypeError(`'store' is not a writable store.`); }\n\n   // Track a single start / end sequence across all animations.\n   let startFired = false;\n   let endFired = false;\n\n   return (node, animations, ...rest) =>\n   {\n      const animationConfig = fn(node, animations, ...rest);\n\n      // Store any existing tick function.\n      const existingTick = animationConfig.tick;\n\n      // Use tick callback to fire events only once when t / time is 0 and 1.\n      animationConfig.tick = (t, u) =>\n      {\n         // If there is any tick function then invoke it.\n         if (existingTick) { existingTick(t, u); }\n\n         if (!startFired && t === 0)\n         {\n            if (store) { store.set(true); }\n            node.dispatchEvent(new CustomEvent('animate:start', { bubbles: true }));\n            startFired = true;\n            endFired = false;\n         }\n\n         if (!endFired && t === 1)\n         {\n            if (store) { store.set(false); }\n            node.dispatchEvent(new CustomEvent('animate:end', { bubbles: true }));\n            endFired = true;\n            startFired = false;\n         }\n      };\n\n      return animationConfig;\n   };\n}\n"],"names":[],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,aAAa,CAAC,EAAE,EAAE,KAAK,GAAG,KAAK,CAAC;AAChD;AACA,GAAG,IAAI,OAAO,EAAE,KAAK,UAAU,EAAE,EAAE,MAAM,IAAI,SAAS,CAAC,CAAC,uBAAuB,CAAC,CAAC,CAAC,EAAE;AACpF,GAAG,IAAI,KAAK,KAAK,KAAK,CAAC,IAAI,CAAC,eAAe,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,IAAI,SAAS,CAAC,CAAC,gCAAgC,CAAC,CAAC,CAAC,EAAE;AAChH;AACA;AACA,GAAG,IAAI,UAAU,GAAG,KAAK,CAAC;AAC1B,GAAG,IAAI,QAAQ,GAAG,KAAK,CAAC;AACxB;AACA,GAAG,OAAO,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,IAAI;AACpC,GAAG;AACH,MAAM,MAAM,eAAe,GAAG,EAAE,CAAC,IAAI,EAAE,UAAU,EAAE,GAAG,IAAI,CAAC,CAAC;AAC5D;AACA;AACA,MAAM,MAAM,YAAY,GAAG,eAAe,CAAC,IAAI,CAAC;AAChD;AACA;AACA,MAAM,eAAe,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC;AAClC,MAAM;AACN;AACA,SAAS,IAAI,YAAY,EAAE,EAAE,YAAY,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE;AAClD;AACA,SAAS,IAAI,CAAC,UAAU,IAAI,CAAC,KAAK,CAAC;AACnC,SAAS;AACT,YAAY,IAAI,KAAK,EAAE,EAAE,KAAK,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC,EAAE;AAC3C,YAAY,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,eAAe,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AACpF,YAAY,UAAU,GAAG,IAAI,CAAC;AAC9B,YAAY,QAAQ,GAAG,KAAK,CAAC;AAC7B,UAAU;AACV;AACA,SAAS,IAAI,CAAC,QAAQ,IAAI,CAAC,KAAK,CAAC;AACjC,SAAS;AACT,YAAY,IAAI,KAAK,EAAE,EAAE,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE;AAC5C,YAAY,IAAI,CAAC,aAAa,CAAC,IAAI,WAAW,CAAC,aAAa,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;AAClF,YAAY,QAAQ,GAAG,IAAI,CAAC;AAC5B,YAAY,UAAU,GAAG,KAAK,CAAC;AAC/B,UAAU;AACV,OAAO,CAAC;AACR;AACA,MAAM,OAAO,eAAe,CAAC;AAC7B,IAAI,CAAC;AACL;;;;"}