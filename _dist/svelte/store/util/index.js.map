{"version":3,"file":"index.js","sources":["../../../../src/svelte/store/util/index.ts"],"sourcesContent":["import type {\n   Readable,\n   Writable,\n   Subscriber,\n   Unsubscriber,\n   Updater }   from 'svelte/store';\n\n/**\n * Provides a basic test for a given variable to test if it has the shape of a readable store by having a `subscribe`\n * function.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ a `subscribe` function.\n *\n * @param store - variable to test that might be a store.\n *\n * @returns Whether the variable tested has the shape of a store.\n *\n * @typeParam T - type of data.\n */\nexport function isReadableStore<T>(store: unknown): store is Readable<T>\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof (store as Record<string, unknown>).subscribe === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Provides a basic test for a given variable to test if it has the shape of a minimal writable store by having a\n * `subscribe` and `set` functions.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ `subscribe` & `set` functions.\n *\n * @param store - variable to test that might be a store.\n *\n * @returns Whether the variable tested has the shape of a {@link MinimalWritable} store.\n *\n * @typeParam T - type of data.\n */\nexport function isMinimalWritableStore<T>(store: unknown): store is MinimalWritable<T>\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof (store as Record<string, unknown>).subscribe === 'function' &&\n          typeof (store as Record<string, unknown>).set === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Provides a basic test for a given variable to test if it has the shape of a writable store by having a `subscribe`\n * `set`, and `update` functions.\n *\n * Note: functions are also objects, so test that the variable might be a function w/ `subscribe`, `set, and `update`\n * functions.\n *\n * @param {*}  store - variable to test that might be a store.\n *\n * @returns Whether the variable tested has the shape of a writable store.\n *\n * @typeParam T - type of data.\n */\nexport function isWritableStore<T>(store: unknown): store is Writable<T>\n{\n   if (store === null || store === void 0) { return false; }\n\n   switch (typeof store)\n   {\n      case 'function':\n      case 'object':\n         return typeof (store as Record<string, unknown>).subscribe === 'function' &&\n          typeof (store as Record<string, unknown>).set === 'function' &&\n           typeof (store as Record<string, unknown>).update === 'function';\n   }\n\n   return false;\n}\n\n/**\n * Subscribes to the given store with the subscriber function provided and ignores the first automatic\n * update. All future updates are dispatched to the subscriber function.\n *\n * @param store - Store to subscribe to...\n *\n * @param subscriber - Function to receive future updates.\n *\n * @returns Store unsubscribe function.\n *\n * @typeParam T - type of data.\n */\nexport function subscribeIgnoreFirst<T>(store: Readable<T> | MinimalWritable<T>, subscriber: Subscriber<T>):\n Unsubscriber\n{\n   let firedFirst = false;\n\n   return store.subscribe((value) =>\n   {\n      if (!firedFirst)\n      {\n         firedFirst = true;\n      }\n      else\n      {\n         subscriber(value);\n      }\n   });\n}\n\n/**\n * Subscribes to the given store with two subscriber functions provided. The first function is invoked on the initial\n * subscription. All future updates are dispatched to the subscriber function.\n *\n * @param store - Store to subscribe to...\n *\n * @param first - Function to receive first update.\n *\n * @param subscriber - Function to receive future updates.\n *\n * @returns Store unsubscribe function.\n *\n * @typeParam T - type of data.\n */\nexport function subscribeFirstRest<T>(store: Readable<T> | MinimalWritable<T>, first: Subscriber<T>,\n subscriber: Subscriber<T>): Unsubscriber\n{\n   let firedFirst = false;\n\n   return store.subscribe((value) =>\n   {\n      if (!firedFirst)\n      {\n         firedFirst = true;\n         first(value);\n      }\n      else\n      {\n         subscriber(value);\n      }\n   });\n}\n\n/**\n * Extends {@link Writable} to allow type differentiation between writing and reading data. This is useful when\n * converting or transforming input data to a different or more specific output.\n *\n * @typeParam W - Writable / input type.\n *\n * @typeParam R - Readable / output type.\n */\nexport interface IOWritable<W, R> extends Readable<R>\n{\n   /**\n    * Set value and inform subscribers.\n    * @param value to set\n    */\n   set(this: void, value: W): void;\n\n   /**\n    * Update value using callback and inform subscribers.\n    * @param updater callback\n    */\n   update(this: void, updater: Updater<W>): void;\n}\n\n/**\n * The minimal requirements of the [writable store contract](https://svelte.dev/docs/svelte-components#script-4-prefix-stores-with-$-to-access-their-values).\n *\n * A minimal writable is a {@link Readable} / subscribable, but only has a `set` method omitting the `update` method\n * from `Writable`.\n *\n * Extends the minimal writable interface to allow type differentiation between writing and reading data. This is\n * useful when converting or transforming input data to a different or more specific output.\n *\n * @typeParam W - Writable / input type.\n *\n * @typeParam R - Readable / output type.\n */\nexport interface MinimalIOWritable<W, R> extends Readable<R>\n{\n   /**\n    * Set value and inform subscribers.\n    * @param value to set\n    */\n   set(this: void, value: W): void;\n}\n\n/**\n * The minimal requirements of the [writable store contract](https://svelte.dev/docs/svelte-components#script-4-prefix-stores-with-$-to-access-their-values).\n *\n * A minimal writable is a {@link Readable} / subscribable, but only has a `set` method omitting the `update` method\n * from `Writable`.\n *\n * @typeParam T - type of data.\n */\nexport interface MinimalWritable<T> extends Readable<T> {\n   /**\n    * Set value and inform subscribers.\n    * @param value to set\n    */\n   set(this: void, value: T): void;\n}\n\n/**\n * Combines a minimal writable Svelte store with a callable function. This type allows a minimal writable store to\n * also act as a function enabling flexible reactive behavior.\n *\n * @typeParam T - The type of value stored in the minimal writable store.\n *\n * @typeParam Args - The tuple of argument types accepted by the function.\n *\n * @typeParam R - The return type of the function.\n */\nexport interface MinimalWritableFn<T, Args extends unknown[], R = void> extends MinimalWritable<T>\n{\n   (...args: Args): R;\n}\n\n/**\n * Combines a writable Svelte store with a callable function. This type allows a writable store to also act as a\n * function enabling flexible reactive behavior.\n *\n * @typeParam T - The type of the value stored in the writable store.\n *\n * @typeParam Args - The tuple of argument types accepted by the function.\n *\n * @typeParam R - The return type of the function.\n */\nexport interface WritableFn<T, Args extends unknown[], R = void> extends Writable<T>\n{\n   (...args: Args): R;\n}\n\n"],"names":[],"mappings":"AAOA;;;;;;;;;;;AAWG;AACG,SAAU,eAAe,CAAI,KAAc,EAAA;IAE9C,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,EAAE;AAAE,QAAA,OAAO,KAAK;IAAE;IAExD,QAAQ,OAAO,KAAK;AAEjB,QAAA,KAAK,UAAU;AACf,QAAA,KAAK,QAAQ;AACV,YAAA,OAAO,OAAQ,KAAiC,CAAC,SAAS,KAAK,UAAU;;AAG/E,IAAA,OAAO,KAAK;AACf;AAEA;;;;;;;;;;;AAWG;AACG,SAAU,sBAAsB,CAAI,KAAc,EAAA;IAErD,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,EAAE;AAAE,QAAA,OAAO,KAAK;IAAE;IAExD,QAAQ,OAAO,KAAK;AAEjB,QAAA,KAAK,UAAU;AACf,QAAA,KAAK,QAAQ;AACV,YAAA,OAAO,OAAQ,KAAiC,CAAC,SAAS,KAAK,UAAU;AACxE,gBAAA,OAAQ,KAAiC,CAAC,GAAG,KAAK,UAAU;;AAGnE,IAAA,OAAO,KAAK;AACf;AAEA;;;;;;;;;;;;AAYG;AACG,SAAU,eAAe,CAAI,KAAc,EAAA;IAE9C,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,MAAM,EAAE;AAAE,QAAA,OAAO,KAAK;IAAE;IAExD,QAAQ,OAAO,KAAK;AAEjB,QAAA,KAAK,UAAU;AACf,QAAA,KAAK,QAAQ;AACV,YAAA,OAAO,OAAQ,KAAiC,CAAC,SAAS,KAAK,UAAU;AACxE,gBAAA,OAAQ,KAAiC,CAAC,GAAG,KAAK,UAAU;AAC3D,gBAAA,OAAQ,KAAiC,CAAC,MAAM,KAAK,UAAU;;AAGvE,IAAA,OAAO,KAAK;AACf;AAEA;;;;;;;;;;;AAWG;AACG,SAAU,oBAAoB,CAAI,KAAuC,EAAE,UAAyB,EAAA;IAGvG,IAAI,UAAU,GAAG,KAAK;AAEtB,IAAA,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,KAAK,KAAI;QAE9B,IAAI,CAAC,UAAU,EACf;YACG,UAAU,GAAG,IAAI;QACpB;aAEA;YACG,UAAU,CAAC,KAAK,CAAC;QACpB;AACH,IAAA,CAAC,CAAC;AACL;AAEA;;;;;;;;;;;;;AAaG;SACa,kBAAkB,CAAI,KAAuC,EAAE,KAAoB,EAClG,UAAyB,EAAA;IAEvB,IAAI,UAAU,GAAG,KAAK;AAEtB,IAAA,OAAO,KAAK,CAAC,SAAS,CAAC,CAAC,KAAK,KAAI;QAE9B,IAAI,CAAC,UAAU,EACf;YACG,UAAU,GAAG,IAAI;YACjB,KAAK,CAAC,KAAK,CAAC;QACf;aAEA;YACG,UAAU,CAAC,KAAK,CAAC;QACpB;AACH,IAAA,CAAC,CAAC;AACL;;;;"}